import type { Express } from "express";
import { createServer, type Server } from "http";
import { storage } from "./storage";
import { insertUserSchema, insertTenantSchema, insertPatientSchema, insertAppointmentSchema, insertPrescriptionSchema, insertLabOrderSchema, insertPharmacySchema, insertInsuranceClaimSchema, insertServicePriceSchema, insertInsurancePlanCoverageSchema, insertClaimLineItemSchema, insertSubscriptionSchema, insertReportSchema, insertMedicalCommunicationSchema, insertCommunicationTranslationSchema, insertSupportedLanguageSchema, insertMedicalPhraseSchema, insertPhraseTranslationSchema, insertLaboratorySchema, insertLabResultSchema, insertLabOrderAssignmentSchema, insertLaboratoryApplicationSchema, insertVitalSignsSchema, insertVisitSummarySchema, insertHealthRecommendationSchema, insertHealthAnalysisSchema, insertMedicationCopaySchema, insertPatientCheckInSchema } from "@shared/schema";
import { authenticateToken, requireRole, AuthenticatedRequest } from "./middleware/auth";
import { setTenantContext, requireTenant } from "./middleware/tenant";
import bcrypt from "bcrypt";
import jwt from "jsonwebtoken";
import { z } from "zod";
import QRCode from "qrcode";
import speakeasy from "speakeasy";
import { aiHealthAnalyzer } from "./ai-health-analyzer";
import { geminiHealthAnalyzer } from "./gemini-health-analyzer";

const JWT_SECRET = process.env.JWT_SECRET || "your-secret-key-change-in-production";

export async function registerRoutes(app: Express): Promise<Server> {
  console.log("DEBUG: registerRoutes called - starting route registration");
  const server = createServer(app);
  
  // Authentication routes (before tenant middleware)
  app.post("/api/auth/login", async (req, res) => {
    try {
      const { username, password, tenantId } = req.body;
      
      console.log("[LOGIN DEBUG] Login attempt:", { username, tenantId: tenantId || 'none', hasPassword: !!password });
      
      if (!username || !password) {
        return res.status(400).json({ message: "Username and password are required" });
      }

      let user;
      
      // For super admin, allow login with email or username and find tenant automatically
      if (username === 'abel@argilette.com' || username === 'abel_admin') {
        // Get all users with this username/email across all tenants
        const allUsers = await storage.getAllUsers();
        user = allUsers.find(u => 
          (u.email === 'abel@argilette.com' || u.username === 'abel_admin') && 
          u.role === 'super_admin'
        );
      } else if (tenantId) {
        // Regular tenant user login - support both tenant UUID and tenant name
        let actualTenantId = tenantId;
        
        // Check if tenantId is a UUID pattern or tenant name
        const uuidPattern = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
        
        if (!uuidPattern.test(tenantId)) {
          // If not a UUID, try to find tenant by name
          const tenants = await storage.getAllTenants();
          console.log("[LOGIN DEBUG] Looking for tenant:", tenantId);
          console.log("[LOGIN DEBUG] Available tenants:", tenants.map(t => t.name));
          const tenant = tenants.find(t => t.name.toLowerCase() === tenantId.toLowerCase());
          if (tenant) {
            actualTenantId = tenant.id;
            console.log("[LOGIN DEBUG] Found tenant ID:", actualTenantId);
          } else {
            console.log("[LOGIN DEBUG] Tenant not found:", tenantId);
            return res.status(400).json({ message: "Organization not found" });
          }
        }
        
        console.log("[LOGIN DEBUG] Getting user by email/username:", username, "tenant:", actualTenantId);
        user = await storage.getUserByEmailOrUsername(username, actualTenantId);
        console.log("[LOGIN DEBUG] Found user in tenant:", user ? { id: user.id, email: user.email } : 'none');
      } else {
        // No tenant ID provided - search for user by email/username across all tenants
        const allUsers = await storage.getAllUsers();
        console.log("[LOGIN DEBUG] Searching all users for:", username);
        user = allUsers.find(u => 
          (u.email === username || u.username === username) && 
          u.role !== 'super_admin' // Exclude super admin from this search
        );
        
        console.log("[LOGIN DEBUG] Found user:", user ? { id: user.id, email: user.email, username: user.username } : 'none');
        
        if (!user) {
          return res.status(401).json({ message: "Invalid credentials" });
        }
      }

      if (!user) {
        console.log("[LOGIN DEBUG] No user found");
        return res.status(401).json({ message: "Invalid credentials" });
      }

      console.log("[LOGIN DEBUG] About to verify password for user:", user.email);
      const passwordMatch = await bcrypt.compare(password, user.password);
      console.log("[LOGIN DEBUG] Password match result:", passwordMatch);

      if (!passwordMatch) {
        console.log("[LOGIN DEBUG] Login failed - password mismatch");
        return res.status(401).json({ message: "Invalid credentials" });
      }

      if (!user.isActive) {
        return res.status(401).json({ message: "Account is disabled" });
      }

      // Check if tenant is suspended (except for super_admin and ARGILETTE platform owner)
      if (user.role !== 'super_admin') {
        const tenant = await storage.getTenant(user.tenantId);
        if (tenant && (tenant.subscriptionStatus === 'suspended' || !tenant.isActive)) {
          // ARGILETTE platform owner has unlimited access - never suspend
          if (tenant.name === 'ARGILETTE' || tenant.type === 'platform') {
            console.log('[AUTH DEBUG] ARGILETTE platform owner - unlimited access granted');
          } else {
            return res.status(403).json({ 
              message: "Account suspended - Trial period expired. Please upgrade to continue using the service.",
              suspensionReason: tenant.suspensionReason || "Trial period expired",
              trialExpired: true
            });
          }
        }
      }

      // Update last login
      await storage.updateUser(user.id, { lastLogin: new Date() });

      const token = jwt.sign(
        { 
          userId: user.id, 
          tenantId: user.tenantId, 
          role: user.role,
          username: user.username 
        },
        JWT_SECRET,
        { expiresIn: "8h" }
      );

      // Create audit log
      await storage.createAuditLog({
        tenantId: user.tenantId,
        userId: user.id,
        entityType: "user",
        entityId: user.id,
        action: "login",
        previousData: null,
        newData: { loginTime: new Date() },
        ipAddress: req.ip || null,
        userAgent: req.get("User-Agent") || null
      });

      res.json({
        token,
        user: {
          id: user.id,
          userId: user.id, // Add userId for compatibility
          username: user.username,
          email: user.email,
          firstName: user.firstName,
          lastName: user.lastName,
          role: user.role,
          tenantId: user.tenantId
        }
      });
    } catch (error) {
      console.error("Login error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Laboratory registration endpoint (public)
  app.post("/api/laboratory-registration", async (req, res) => {
    try {
      const { tenant: labData, admin } = req.body;
      
      if (!labData || !admin) {
        return res.status(400).json({ 
          message: "Laboratory and admin information are required" 
        });
      }

      // Create the laboratory tenant
      const tenantData = {
        name: labData.name,
        type: "laboratory" as const,
        subdomain: labData.subdomain,
        settings: labData.settings || {}
      };

      console.log("Creating laboratory tenant:", tenantData);
      const tenant = await storage.createTenant(tenantData);
      
      // Generate a temporary password for the admin
      const tempPassword = Math.random().toString(36).slice(-8);
      const hashedPassword = await bcrypt.hash(tempPassword, 10);
      
      // Create the admin user
      const adminData = {
        tenantId: tenant.id,
        username: admin.email,
        email: admin.email,
        password: hashedPassword,
        firstName: admin.firstName,
        lastName: admin.lastName,
        role: "tenant_admin" as const,
        isActive: true
      };

      console.log("Creating lab admin user:", { ...adminData, password: "[HIDDEN]" });
      const adminUser = await storage.createUser(adminData);

      console.log(`Laboratory registered successfully. Admin credentials: ${admin.email} / ${tempPassword}`);

      res.status(201).json({
        message: "Laboratory registered successfully",
        tenant: {
          id: tenant.id,
          name: tenant.name,
          subdomain: tenant.subdomain
        },
        admin: {
          id: adminUser.id,
          email: adminUser.email,
          tempPassword: tempPassword
        }
      });

    } catch (error) {
      console.error("Laboratory registration error:", error);
      res.status(500).json({ 
        message: "Registration failed", 
        error: error instanceof Error ? error.message : "Unknown error"
      });
    }
  });

  // Pharmacy registration endpoint (public) - Auto-approve and create tenant
  app.post("/api/pharmacy-registration", async (req, res) => {
    try {
      console.log("Pharmacy registration request:", JSON.stringify(req.body, null, 2));
      
      const { tenant: pharmacyData, admin } = req.body;
      
      if (!pharmacyData || !admin) {
        return res.status(400).json({ 
          message: "Pharmacy and admin information are required" 
        });
      }

      // Create the pharmacy tenant immediately (auto-approved)
      const tenantData = {
        name: pharmacyData.name || "Unnamed Pharmacy",
        type: "pharmacy" as const,
        subdomain: pharmacyData.subdomain,
        settings: pharmacyData.settings || {}
      };

      console.log("Creating pharmacy tenant (auto-approved):", tenantData);
      const tenant = await storage.createTenant(tenantData);
      
      // Generate a temporary password for the admin
      const tempPassword = Math.random().toString(36).slice(-8);
      const hashedPassword = await bcrypt.hash(tempPassword, 10);
      
      // Create the admin user
      const adminData = {
        tenantId: tenant.id,
        username: admin.email,
        email: admin.email,
        password: hashedPassword,
        firstName: admin.firstName,
        lastName: admin.lastName,
        role: "tenant_admin" as const,
        isActive: true
      };

      console.log("Creating pharmacy admin user:", { ...adminData, password: "[HIDDEN]" });
      const adminUser = await storage.createUser(adminData);

      console.log(`Pharmacy registered successfully. Admin credentials: ${admin.email} / ${tempPassword}`);

      res.status(201).json({
        message: "Pharmacy registered and approved successfully",
        tenant: {
          id: tenant.id,
          name: tenant.name,
          subdomain: tenant.subdomain,
          status: "approved"
        },
        admin: {
          id: adminUser.id,
          email: adminUser.email,
          tempPassword: tempPassword
        },
        loginInfo: {
          message: "Your pharmacy is now active! You can login with these credentials:",
          email: admin.email,
          tempPassword: tempPassword,
          loginUrl: `${req.protocol}://${req.get('host')}/login`
        }
      });

    } catch (error) {
      console.error("Pharmacy registration error:", error);
      res.status(500).json({ 
        message: "Registration failed", 
        error: error instanceof Error ? error.message : "Unknown error"
      });
    }
  });

  // NOTE: Individual routes handle their own tenant context middleware

  app.post("/api/auth/register", authenticateToken, requireTenant, async (req, res) => {
    try {
      const userData = insertUserSchema.parse(req.body);
      
      // Check if user already exists
      const existingUser = await storage.getUserByUsername(userData.username, userData.tenantId);
      if (existingUser) {
        return res.status(409).json({ message: "Username already exists" });
      }

      const existingEmail = await storage.getUserByEmail(userData.email, userData.tenantId);
      if (existingEmail) {
        return res.status(409).json({ message: "Email already exists" });
      }

      // Hash password
      const hashedPassword = await bcrypt.hash(userData.password, 12);
      
      const user = await storage.createUser({
        ...userData,
        password: hashedPassword
      });

      // Create audit log
      await storage.createAuditLog({
        tenantId: user.tenantId,
        userId: user.id,
        entityType: "user",
        entityId: user.id,
        action: "register",
        previousData: null,
        newData: { username: user.username, email: user.email, role: user.role },
        ipAddress: req.ip || null,
        userAgent: req.get("User-Agent") || null
      });

      res.status(201).json({
        message: "User created successfully",
        user: {
          id: user.id,
          username: user.username,
          email: user.email,
          firstName: user.firstName,
          lastName: user.lastName,
          role: user.role,
          tenantId: user.tenantId
        }
      });
    } catch (error) {
      console.error("Registration error:", error);
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Invalid input data", errors: error.errors });
      }
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Protected routes - require authentication
  // NOTE: Individual routes handle their own authentication middleware

  // User profile
  app.get("/api/user/profile", authenticateToken, async (req, res) => {
    try {
      const user = await storage.getUser(req.user!.id);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }

      res.json({
        id: user.id,
        username: user.username,
        email: user.email,
        firstName: user.firstName,
        lastName: user.lastName,
        role: user.role,
        tenantId: user.tenantId,
        lastLogin: user.lastLogin
      });
    } catch (error) {
      console.error("Profile error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // User profile routes
  app.get("/api/users/profile", authenticateToken, async (req, res) => {
    try {
      // Return current user's profile
      const user = await storage.getUser(req.user!.id);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      
      // Remove sensitive data before sending
      const { password, ...userProfile } = user;
      res.json(userProfile);
    } catch (error) {
      console.error("Get user profile error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.patch("/api/users/profile", authenticateToken, async (req, res) => {
    try {
      const { firstName, lastName, email, phone, bio, profileImage } = req.body;
      
      // Validate input
      if (!firstName || !lastName || !email) {
        return res.status(400).json({ message: "First name, last name, and email are required" });
      }

      const updateData = {
        firstName,
        lastName,
        email,
        phone: phone || null,
        bio: bio || null,
        profileImage: profileImage || null
      };

      const updatedUser = await storage.updateUser(req.user!.id, updateData);
      
      if (!updatedUser) {
        return res.status(404).json({ message: "User not found" });
      }

      // Create audit log
      await storage.createAuditLog({
        tenantId: req.user!.tenantId,
        userId: req.user!.id,
        entityType: "user",
        entityId: req.user!.id,
        action: "update_profile",
        previousData: null,
        newData: updateData,
        ipAddress: req.ip || null,
        userAgent: req.get("User-Agent") || null
      });

      // Remove sensitive data before sending
      const { password, ...userProfile } = updatedUser;
      res.json(userProfile);
    } catch (error) {
      console.error("Update user profile error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.post("/api/users/change-password", authenticateToken, async (req, res) => {
    try {
      const { currentPassword, newPassword } = req.body;
      
      if (!currentPassword || !newPassword) {
        return res.status(400).json({ message: "Current password and new password are required" });
      }

      if (newPassword.length < 8) {
        return res.status(400).json({ message: "New password must be at least 8 characters long" });
      }

      // Get current user
      const user = await storage.getUser(req.user!.id);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }

      // Verify current password
      const isCurrentPasswordValid = await bcrypt.compare(currentPassword, user.password);
      if (!isCurrentPasswordValid) {
        return res.status(400).json({ message: "Current password is incorrect" });
      }

      // Hash new password
      const hashedNewPassword = await bcrypt.hash(newPassword, 10);

      // Update password
      const updatedUser = await storage.updateUser(req.user!.id, { password: hashedNewPassword });
      
      if (!updatedUser) {
        return res.status(404).json({ message: "Failed to update password" });
      }

      // Create audit log
      await storage.createAuditLog({
        tenantId: req.user!.tenantId,
        userId: req.user!.id,
        entityType: "user",
        entityId: req.user!.id,
        action: "change_password",
        previousData: null,
        newData: { message: "Password changed successfully" },
        ipAddress: req.ip || null,
        userAgent: req.get("User-Agent") || null
      });

      res.json({ message: "Password changed successfully" });
    } catch (error) {
      console.error("Change password error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Security settings routes
  app.get("/api/users/security", authenticateToken, async (req, res) => {
    try {
      // For now, return mock security settings
      res.json({
        twoFactorEnabled: false,
        backupCodesCount: 0,
        lastPasswordChange: new Date().toISOString()
      });
    } catch (error) {
      console.error("Get security settings error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // 2FA setup routes
  app.post("/api/users/2fa/setup", authenticateToken, async (req, res) => {
    try {
      const user = await storage.getUser(req.user!.id);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }

      // Generate secret for 2FA
      const secret = speakeasy.generateSecret({
        name: `${user.firstName} ${user.lastName} (${user.email})`,
        issuer: 'Healthcare Platform',
        length: 32
      });

      // Generate QR code
      const qrCodeUrl = secret.otpauth_url;
      const qrCodeImage = await QRCode.toDataURL(qrCodeUrl!);

      // Generate backup codes
      const backupCodes = [];
      for (let i = 0; i < 8; i++) {
        const code = Math.random().toString(36).substr(2, 5).toUpperCase() + 
                    '-' + 
                    Math.random().toString(36).substr(2, 5).toUpperCase();
        backupCodes.push(code);
      }

      // Store the secret temporarily (in production, you'd store this in the database)
      // For now, we'll just return it to the client
      res.json({ 
        qrCode: qrCodeImage, 
        backupCodes,
        secret: secret.base32 // This would normally be stored securely in the database
      });
    } catch (error) {
      console.error("Setup 2FA error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.post("/api/users/2fa/verify", authenticateToken, async (req, res) => {
    try {
      const { code, secret } = req.body;
      
      if (!code || !secret) {
        return res.status(400).json({ message: "Verification code and secret are required" });
      }

      // Verify the TOTP code
      const verified = speakeasy.totp.verify({
        secret: secret,
        encoding: 'base32',
        token: code,
        window: 2 // Allow 2 time steps in either direction for clock drift
      });

      if (verified) {
        // In production, you would:
        // 1. Store the secret in the database for the user
        // 2. Mark 2FA as enabled for the user
        // 3. Invalidate any existing sessions to force re-authentication
        
        res.json({ success: true });
      } else {
        res.status(400).json({ message: "Invalid verification code" });
      }
    } catch (error) {
      console.error("Verify 2FA error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.post("/api/users/2fa/disable", authenticateToken, async (req, res) => {
    try {
      res.json({ success: true });
    } catch (error) {
      console.error("Disable 2FA error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Login sessions routes
  app.get("/api/users/sessions", authenticateToken, async (req, res) => {
    try {
      // Return mock session data for demo
      const sessions = [
        {
          id: "session-1",
          device: "MacBook Pro",
          browser: "Chrome 120.0",
          location: "San Francisco, CA",
          ipAddress: "192.168.1.100",
          lastActive: "2 minutes ago",
          isCurrent: true
        },
        {
          id: "session-2", 
          device: "iPhone 15",
          browser: "Safari Mobile",
          location: "San Francisco, CA",
          ipAddress: "192.168.1.101",
          lastActive: "1 hour ago",
          isCurrent: false
        },
        {
          id: "session-3",
          device: "Windows PC",
          browser: "Edge 119.0",
          location: "New York, NY",
          ipAddress: "203.0.113.50",
          lastActive: "3 days ago",
          isCurrent: false
        }
      ];

      res.json(sessions);
    } catch (error) {
      console.error("Get sessions error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.delete("/api/users/sessions/:sessionId", authenticateToken, async (req, res) => {
    try {
      const { sessionId } = req.params;
      
      // Create audit log
      await storage.createAuditLog({
        tenantId: req.user!.tenantId,
        userId: req.user!.id,
        entityType: "session",
        entityId: sessionId,
        action: "revoke_session",
        previousData: null,
        newData: { sessionId },
        ipAddress: req.ip || null,
        userAgent: req.get("User-Agent") || null
      });

      res.json({ success: true });
    } catch (error) {
      console.error("Revoke session error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // API Keys routes
  app.get("/api/users/api-keys", authenticateToken, async (req, res) => {
    try {
      // Return mock API keys for demo
      const apiKeys = [
        {
          id: "key-1",
          name: "Production API",
          keyPreview: "pk_live_1234...5678",
          createdAt: "2024-01-15T10:30:00Z",
          lastUsed: "2024-01-27T14:22:00Z",
          permissions: ["read", "write"]
        },
        {
          id: "key-2",
          name: "Development Testing",
          keyPreview: "pk_test_abcd...efgh",
          createdAt: "2024-01-20T09:15:00Z",
          lastUsed: null,
          permissions: ["read"]
        }
      ];

      res.json(apiKeys);
    } catch (error) {
      console.error("Get API keys error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.post("/api/users/api-keys", authenticateToken, async (req, res) => {
    try {
      const { name } = req.body;
      
      if (!name || !name.trim()) {
        return res.status(400).json({ message: "API key name is required" });
      }

      // Generate mock API key
      const newKey = {
        id: `key-${Date.now()}`,
        name: name.trim(),
        key: `pk_live_${Math.random().toString(36).substr(2, 32)}`,
        keyPreview: `pk_live_${Math.random().toString(36).substr(2, 4)}...${Math.random().toString(36).substr(2, 4)}`,
        createdAt: new Date().toISOString(),
        lastUsed: null,
        permissions: ["read", "write"]
      };

      // Create audit log
      await storage.createAuditLog({
        tenantId: req.user!.tenantId,
        userId: req.user!.id,
        entityType: "api_key",
        entityId: newKey.id,
        action: "create_api_key",
        previousData: null,
        newData: { name: newKey.name },
        ipAddress: req.ip || null,
        userAgent: req.get("User-Agent") || null
      });

      res.status(201).json(newKey);
    } catch (error) {
      console.error("Create API key error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.delete("/api/users/api-keys/:keyId", authenticateToken, async (req, res) => {
    try {
      const { keyId } = req.params;

      // Create audit log
      await storage.createAuditLog({
        tenantId: req.user!.tenantId,
        userId: req.user!.id,
        entityType: "api_key",
        entityId: keyId,
        action: "delete_api_key",
        previousData: null,
        newData: { keyId },
        ipAddress: req.ip || null,
        userAgent: req.get("User-Agent") || null
      });

      res.json({ success: true });
    } catch (error) {
      console.error("Delete API key error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // User preferences routes
  app.get("/api/users/preferences", authenticateToken, async (req, res) => {
    try {
      // Get saved language preference from localStorage equivalent (could be stored in user profile)
      // For now, return preferences but don't override language if user has already selected one
      const savedLanguage = req.headers['x-user-language'] || 'en';
      
      const preferences = {
        emailNotifications: true,
        smsNotifications: false,
        appointmentReminders: true,
        prescriptionAlerts: true,
        marketingEmails: false,
        language: savedLanguage,
        timezone: 'America/New_York',
        dateFormat: 'MM/DD/YYYY',
        theme: 'light',
        autoLogout: 30,
        dataRetention: true
      };

      res.json(preferences);
    } catch (error) {
      console.error("Get preferences error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.patch("/api/users/preferences", authenticateToken, async (req, res) => {
    try {
      const preferences = req.body;
      
      // In production, you would save these to the database
      // For now, just validate and return success
      
      // Create audit log
      await storage.createAuditLog({
        tenantId: req.user!.tenantId,
        userId: req.user!.id,
        entityType: "user_preferences",
        entityId: req.user!.id,
        action: "update_preferences",
        previousData: null,
        newData: preferences,
        ipAddress: req.ip || null,
        userAgent: req.get("User-Agent") || null
      });

      res.json({ success: true, preferences });
    } catch (error) {
      console.error("Update preferences error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Get users by role (for fetching providers, etc.)
  app.get("/api/users", authenticateToken, requireTenant, async (req, res) => {
    try {
      const { role } = req.query;
      const tenantId = req.tenant!.id;
      
      if (role) {
        const users = await storage.getUsersByRole(role as string, tenantId);
        res.json(users);
      } else {
        const users = await storage.getUsersByTenant(tenantId);
        res.json(users);
      }
    } catch (error) {
      console.error("Get users error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Get current tenant info
  app.get("/api/tenant/current", authenticateToken, async (req, res) => {
    try {
      if (!req.user?.tenantId) {
        return res.status(400).json({ message: "No tenant context" });
      }
      
      const tenant = await storage.getTenant(req.user.tenantId);
      if (!tenant) {
        return res.status(404).json({ message: "Tenant not found" });
      }
      
      res.json(tenant);
    } catch (error) {
      console.error("Get current tenant error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Tenant management routes
  app.get("/api/tenants", authenticateToken, requireRole(["super_admin"]), async (req, res) => {
    try {
      const tenants = await storage.getAllTenants();
      res.json(tenants);
    } catch (error) {
      console.error("Get tenants error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.post("/api/tenants", authenticateToken, requireRole(["super_admin"]), async (req, res) => {
    try {
      const tenantData = insertTenantSchema.parse(req.body);
      const tenant = await storage.createTenant(tenantData);

      // Create audit log
      await storage.createAuditLog({
        tenantId: tenant.id,
        userId: req.user!.id,
        entityType: "tenant",
        entityId: tenant.id,
        action: "create",
        previousData: null,
        newData: tenant,
        ipAddress: req.ip || null,
        userAgent: req.get("User-Agent") || null
      });

      res.status(201).json(tenant);
    } catch (error) {
      console.error("Create tenant error:", error);
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Invalid input data", errors: error.errors });
      }
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Public organization registration (no authentication required)
  app.post("/api/register-organization", async (req, res) => {
    try {
      const { 
        organizationName, 
        organizationType, 
        adminFirstName, 
        adminLastName, 
        adminEmail, 
        adminPassword,
        phoneNumber,
        address,
        description 
      } = req.body;

      // Validate required fields
      if (!organizationName || !organizationType || !adminFirstName || !adminLastName || !adminEmail || !adminPassword) {
        return res.status(400).json({ message: "All required fields must be provided" });
      }

      // Create organization subdomain from name
      const subdomain = organizationName.toLowerCase()
        .replace(/[^a-z0-9\s]/g, '')
        .replace(/\s+/g, '-')
        .substring(0, 50);

      // Check if subdomain already exists
      const existingTenant = await storage.getTenantBySubdomain(subdomain);
      if (existingTenant) {
        return res.status(400).json({ message: "Organization name already exists. Please choose a different name." });
      }

      // Create tenant data
      const tenantData = {
        name: organizationName,
        type: organizationType,
        subdomain,
        phoneNumber: phoneNumber || null,
        address: address || null,
        description: description || null,
        isActive: true
      };

      const tenant = await storage.createTenant(tenantData);

      // Hash admin password
      const hashedPassword = await bcrypt.hash(adminPassword, 10);

      // Create admin user for the organization
      const adminUser = await storage.createUser({
        username: adminEmail.split('@')[0], // Use email prefix as username
        email: adminEmail,
        password: hashedPassword,
        firstName: adminFirstName,
        lastName: adminLastName,
        role: "tenant_admin",
        tenantId: tenant.id,
        isActive: true
      });

      // Create audit log for public registration
      await storage.createAuditLog({
        tenantId: tenant.id,
        userId: adminUser.id,
        entityType: "tenant",
        entityId: tenant.id,
        action: "public_registration",
        previousData: null,
        newData: { organizationName, organizationType, adminEmail },
        ipAddress: req.ip || null,
        userAgent: req.get("User-Agent") || null
      });

      res.status(201).json({ 
        message: "Organization registered successfully!",
        organization: {
          id: tenant.id,
          name: tenant.name,
          type: tenant.type,
          subdomain: tenant.subdomain
        },
        admin: {
          id: adminUser.id,
          email: adminUser.email,
          firstName: adminUser.firstName,
          lastName: adminUser.lastName
        }
      });
    } catch (error) {
      console.error("Organization registration error:", error);
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Invalid input data", errors: error.errors });
      }
      res.status(500).json({ message: "Failed to register organization" });
    }
  });

  // Patient management routes - require tenant context
  app.use("/api/patients", requireTenant);

  app.get("/api/patients", async (req, res) => {
    try {
      const { limit = "50", offset = "0", search } = req.query;
      const tenantId = req.tenant!.id;
      
      // Get full tenant info to check type
      const tenant = await storage.getTenant(tenantId);
      const tenantType = tenant?.type;

      let patients;
      if (search && typeof search === "string") {
        // For pharmacies, search only patients with prescriptions sent to them
        if (tenantType === "pharmacy") {
          patients = await storage.getPatientsWithPrescriptionsForPharmacy(tenantId, search);
        } else {
          patients = await storage.searchPatients(tenantId, search);
        }
      } else {
        // For pharmacies, get only patients with prescriptions sent to them
        if (tenantType === "pharmacy") {
          patients = await storage.getPatientsWithPrescriptionsForPharmacy(tenantId);
        } else {
          patients = await storage.getPatientsByTenant(tenantId, parseInt(limit as string), parseInt(offset as string));
        }
      }

      res.json(patients);
    } catch (error) {
      console.error("Get patients error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.get("/api/patients/:id", async (req, res) => {
    try {
      const patient = await storage.getPatient(req.params.id, req.tenant!.id);
      if (!patient) {
        return res.status(404).json({ message: "Patient not found" });
      }
      res.json(patient);
    } catch (error) {
      console.error("Get patient error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.post("/api/patients", requireRole(["physician", "nurse", "receptionist", "tenant_admin", "director"]), async (req, res) => {
    try {
      // Generate MRN automatically
      const mrn = `MRN${Date.now()}${Math.random().toString(36).substr(2, 5).toUpperCase()}`;
      
      // Prepare patient data with proper date conversion
      const requestData = {
        ...req.body,
        tenantId: req.tenant!.id,
        mrn: mrn,
        // Convert dateOfBirth string to Date if it's a string
        dateOfBirth: typeof req.body.dateOfBirth === 'string' 
          ? new Date(req.body.dateOfBirth) 
          : req.body.dateOfBirth
      };

      const patientData = insertPatientSchema.parse(requestData);

      const patient = await storage.createPatient(patientData);

      // Create audit log
      await storage.createAuditLog({
        tenantId: req.tenant!.id,
        userId: req.user!.id,
        entityType: "patient",
        entityId: patient.id,
        action: "create",
        previousData: null,
        newData: patient,
        ipAddress: req.ip || null,
        userAgent: req.get("User-Agent") || null
      });

      res.status(201).json(patient);
    } catch (error) {
      console.error("Create patient error:", error);
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Invalid input data", errors: error.errors });
      }
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Appointment management routes
  app.use("/api/appointments", requireTenant);

  app.get("/api/appointments", async (req, res) => {
    try {
      const { date, providerId } = req.query;
      const tenantId = req.tenant!.id;

      let appointments;
      const queryDate = date ? new Date(date as string) : undefined;

      if (providerId) {
        appointments = await storage.getAppointmentsByProvider(providerId as string, tenantId, queryDate);
      } else {
        appointments = await storage.getAppointmentsByTenant(tenantId, queryDate);
      }

      res.json(appointments);
    } catch (error) {
      console.error("Get appointments error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // GET appointments by provider ID (specific route for doctor dashboard)
  app.get("/api/appointments/provider/:providerId", authenticateToken, requireTenant, async (req, res) => {
    try {
      const { providerId } = req.params;
      console.log("[DEBUG] Getting appointments for provider:", providerId);
      
      const appointments = await storage.getAppointmentsByProvider(providerId, req.tenant!.id);
      res.json(appointments);
    } catch (error) {
      console.error("Get provider appointments error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.post("/api/appointments", authenticateToken, requireTenant, async (req, res) => {
    try {
      console.log("[DEBUG] Creating appointment - User:", req.user?.role, "User ID:", req.user?.userId, "Tenant:", req.tenant?.id);
      console.log("[DEBUG] Request body:", req.body);
      
      // Check if user has permission to create appointments
      const allowedRoles = ["physician", "nurse", "receptionist", "tenant_admin", "director", "super_admin", "billing_staff", "pharmacist"];
      if (!allowedRoles.includes(req.user!.role)) {
        console.log("[DEBUG] Permission denied for role:", req.user!.role);
        return res.status(403).json({ 
          message: "Insufficient permissions to create appointments",
          required: allowedRoles,
          current: req.user!.role
        });
      }
      
      // Convert appointmentDate string to Date object
      const requestData = { ...req.body };
      if (requestData.appointmentDate && typeof requestData.appointmentDate === 'string') {
        requestData.appointmentDate = new Date(requestData.appointmentDate);
      }
      
      const appointmentData = insertAppointmentSchema.parse({
        ...requestData,
        tenantId: req.tenant!.id
      });

      const appointment = await storage.createAppointment(appointmentData);

      // Create audit log
      await storage.createAuditLog({
        tenantId: req.tenant!.id,
        userId: req.user!.id,
        entityType: "appointment",
        entityId: appointment.id,
        action: "create",
        previousData: null,
        newData: appointment,
        ipAddress: req.ip || null,
        userAgent: req.get("User-Agent") || null
      });

      res.status(201).json(appointment);
    } catch (error) {
      console.error("Create appointment error:", error);
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Invalid input data", errors: error.errors });
      }
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Update appointment (PATCH)
  app.patch("/api/appointments/:id", authenticateToken, requireRole(["physician", "nurse", "receptionist", "tenant_admin", "director", "super_admin"]), async (req, res) => {
    try {
      const { id } = req.params;
      const updateData = { ...req.body };

      // Handle date fields properly if they exist
      if (updateData.appointmentDate && typeof updateData.appointmentDate === 'string') {
        updateData.appointmentDate = new Date(updateData.appointmentDate);
      }

      const updatedAppointment = await storage.updateAppointment(id, updateData, req.tenant!.id);
      
      if (!updatedAppointment) {
        return res.status(404).json({ message: "Appointment not found" });
      }

      // Create audit log
      await storage.createAuditLog({
        tenantId: req.tenant!.id,
        userId: req.user!.id,
        entityType: "appointment",
        entityId: id,
        action: "update",
        previousData: null,
        newData: updatedAppointment,
        ipAddress: req.ip || null,
        userAgent: req.get("User-Agent") || null
      });

      res.json(updatedAppointment);
    } catch (error) {
      console.error("Update appointment error:", error);
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Invalid input data", errors: error.errors });
      }
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Prescription management routes
  app.get("/api/prescriptions", authenticateToken, requireTenant, async (req, res) => {
    try {
      console.log("Prescriptions API - User:", req.user?.id, "Tenant:", req.tenant?.id);
      const { patientId } = req.query;
      const tenantId = req.tenant!.id;
      
      // Get full tenant info to check type
      const tenant = await storage.getTenant(tenantId);
      const tenantType = tenant?.type;

      let prescriptions;
      if (patientId) {
        prescriptions = await storage.getPrescriptionsByPatient(patientId as string, tenantId);
      } else {
        // For pharmacies, get only prescriptions sent to them with provider info
        if (tenantType === "pharmacy") {
          console.log("Getting prescriptions for pharmacy tenant:", tenantId);
          prescriptions = await storage.getPrescriptionsByPharmacy(tenantId);
          console.log("Found prescriptions:", prescriptions.length);
        } else {
          // For healthcare providers, get prescriptions they created
          prescriptions = await storage.getPrescriptionsByTenant(tenantId);
        }
      }

      res.json(prescriptions);
    } catch (error) {
      console.error("Get prescriptions error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.patch("/api/prescriptions/:id", authenticateToken, requireTenant, async (req, res) => {
    try {
      const { id } = req.params;
      const updates = req.body;
      const tenantId = req.tenant!.id;

      const updatedPrescription = await storage.updatePrescription(id, updates, tenantId);
      
      if (!updatedPrescription) {
        return res.status(404).json({ message: "Prescription not found" });
      }

      // Create audit log
      await storage.createAuditLog({
        tenantId: tenantId,
        userId: req.user!.id,
        entityType: "prescription",
        entityId: id,
        action: "UPDATE",
        previousData: null,
        newData: updatedPrescription,
        ipAddress: req.ip || null,
        userAgent: req.get('User-Agent') || null
      });

      res.json(updatedPrescription);
    } catch (error) {
      console.error("Update prescription error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // File insurance claim for prescription
  app.post("/api/prescriptions/file-claim", authenticateToken, requireTenant, async (req, res) => {
    try {
      const { prescriptionId, patientId, medicationName, dosage, quantity } = req.body;
      const tenantId = req.tenant!.id;

      // For pharmacies, we need to get the prescription from the pharmacy's perspective
      // But the prescription belongs to the original hospital/clinic tenant
      let prescription;
      const tenant = await storage.getTenant(tenantId);
      
      if (tenant?.type === "pharmacy") {
        // For pharmacies, we need to find the prescription by ID across all tenants
        // since it was created by a different tenant (hospital/clinic)
        const allTenants = await storage.getAllTenants();
        for (const t of allTenants) {
          if (t.type === "hospital" || t.type === "clinic") {
            try {
              prescription = await storage.getPrescription(prescriptionId, t.id);
              if (prescription && prescription.pharmacyTenantId === tenantId) {
                break;
              }
            } catch (error) {
              // Continue searching
            }
          }
        }
      } else {
        prescription = await storage.getPrescription(prescriptionId, tenantId);
      }

      if (!prescription) {
        return res.status(404).json({ message: "Prescription not found" });
      }

      // Get patient information from the original tenant
      const patient = await storage.getPatient(patientId, prescription.tenantId);
      if (!patient) {
        return res.status(404).json({ message: "Patient not found" });
      }

      // Get service price for medication dispensing
      const servicePrices = await storage.getServicePrices(tenantId);
      const medicationService = servicePrices.find(sp => 
        sp.serviceCategory === "medication" || 
        sp.serviceName.toLowerCase().includes("dispensing") ||
        sp.serviceName.toLowerCase().includes("medication")
      );

      const basePrice = medicationService?.price || 25.00; // Default medication dispensing fee
      const totalAmount = basePrice * (quantity || 1);

      // Calculate insurance coverage (80% coverage, 20% patient copay as standard)
      const coveragePercentage = 0.80; // 80% insurance coverage
      const insuranceAmount = Math.round(totalAmount * coveragePercentage * 100) / 100;
      const patientCopay = Math.round(totalAmount * (1 - coveragePercentage) * 100) / 100;

      // Create insurance claim with proper breakdown
      const claimData = {
        tenantId: tenantId,
        patientId: patientId,
        claimNumber: `RX-${Date.now()}`,
        totalAmount: totalAmount,
        totalInsuranceAmount: insuranceAmount,
        totalPatientCopay: patientCopay,
        status: "submitted" as const,
        notes: `Insurance claim for ${medicationName} ${dosage} - Qty: ${quantity}. Insurance covers $${insuranceAmount} (80%), Patient pays $${patientCopay} (20%)`
      };

      const insuranceClaim = await storage.createInsuranceClaim(claimData);

      // Update prescription status to filled (use original tenant ID)
      await storage.updatePrescription(prescriptionId, { 
        status: "filled",
        filledDate: new Date()
      }, prescription.tenantId);

      // Create audit log
      await storage.createAuditLog({
        tenantId: tenantId,
        userId: req.user!.id,
        entityType: "insurance_claim",
        entityId: insuranceClaim.id,
        action: "create",
        previousData: null,
        newData: insuranceClaim,
        ipAddress: req.ip || null,
        userAgent: req.get('User-Agent') || null
      });

      res.status(201).json({ 
        message: "Insurance claim filed successfully",
        claim: insuranceClaim,
        prescription: prescription
      });
    } catch (error) {
      console.error("File insurance claim error:", error);
      res.status(500).json({ message: "Failed to file insurance claim" });
    }
  });

  app.post("/api/prescriptions", requireRole(["physician", "nurse", "tenant_admin", "director", "super_admin"]), async (req, res) => {
    try {
      // Convert string dates to Date objects
      const requestData = { ...req.body };
      if (requestData.expiryDate && typeof requestData.expiryDate === 'string') {
        requestData.expiryDate = new Date(requestData.expiryDate);
      }
      
      // Prepare prescription data with all required fields including dates
      const prescriptionData = {
        ...requestData,
        tenantId: req.tenant!.id,
        providerId: req.user!.id,
        appointmentId: requestData.appointmentId || null,
        pharmacyTenantId: requestData.pharmacyTenantId || null,
        prescribedDate: new Date(),
        expiryDate: requestData.expiryDate ? new Date(requestData.expiryDate) : new Date(Date.now() + 365 * 24 * 60 * 60 * 1000) // Default 1 year
      };
      
      const validatedData = insertPrescriptionSchema.parse(prescriptionData);

      const prescription = await storage.createPrescription(validatedData);

      // Create audit log
      await storage.createAuditLog({
        tenantId: req.tenant!.id,
        userId: req.user!.id,
        entityType: "prescription",
        entityId: prescription.id,
        action: "create",
        previousData: null,
        newData: prescription,
        ipAddress: req.ip || null,
        userAgent: req.get("User-Agent") || null
      });

      res.status(201).json(prescription);
    } catch (error) {
      console.error("Create prescription error:", error);
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Invalid input data", errors: error.errors });
      }
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Pharmacy routes
  app.get("/api/pharmacies", authenticateToken, requireTenant, async (req, res) => {
    try {
      const pharmacies = await storage.getActivePharmacies(req.tenantId!);
      res.json(pharmacies);
    } catch (error) {
      console.error("Error fetching pharmacies:", error);
      res.status(500).json({ message: "Failed to fetch pharmacies" });
    }
  });

  app.post("/api/pharmacies", authenticateToken, requireRole(["tenant_admin", "director", "super_admin"]), requireTenant, async (req, res) => {
    try {
      const pharmacyData = insertPharmacySchema.parse({
        ...req.body,
        tenantId: req.tenantId
      });

      const pharmacy = await storage.createPharmacy(pharmacyData);

      // Create audit log
      await storage.createAuditLog({
        tenantId: req.tenantId!,
        userId: req.userId!,
        entityType: "pharmacy",
        entityId: pharmacy.id,
        action: "CREATE",
        previousData: null,
        newData: pharmacy,
        ipAddress: req.ip || null,
        userAgent: req.get('User-Agent') || null
      });

      res.status(201).json(pharmacy);
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Invalid pharmacy data", errors: error.errors });
      }
      console.error("Error creating pharmacy:", error);
      res.status(500).json({ message: "Failed to create pharmacy" });
    }
  });

  // Lab order management routes
  app.get("/api/lab-orders", authenticateToken, requireTenant, async (req, res) => {
    try {
      const { patientId, pending } = req.query;
      const tenantId = req.tenant!.id;

      let labOrders;
      if (patientId) {
        labOrders = await storage.getLabOrdersByPatient(patientId as string, tenantId);
      } else if (pending === "true") {
        labOrders = await storage.getPendingLabOrders(tenantId);
      } else {
        labOrders = await storage.getLabOrdersByTenant(tenantId);
      }

      res.json(labOrders);
    } catch (error) {
      console.error("Get lab orders error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.post("/api/lab-orders", requireRole(["physician", "nurse", "tenant_admin", "director", "super_admin"]), async (req, res) => {
    try {
      // Convert string dates to Date objects and prepare data
      const requestData = { ...req.body };
      if (requestData.orderedDate && typeof requestData.orderedDate === 'string') {
        requestData.orderedDate = new Date(requestData.orderedDate);
      }
      
      const labOrderData = {
        ...requestData,
        tenantId: req.tenant!.id,
        providerId: req.user!.id,
        orderedDate: requestData.orderedDate || new Date(),
        appointmentId: requestData.appointmentId || null,
        labTenantId: requestData.labTenantId || null
      };

      const validatedData = insertLabOrderSchema.parse(labOrderData);

      const labOrder = await storage.createLabOrder(validatedData);

      // Create audit log
      await storage.createAuditLog({
        tenantId: req.tenant!.id,
        userId: req.user!.id,
        entityType: "lab_order",
        entityId: labOrder.id,
        action: "create",
        previousData: null,
        newData: labOrder,
        ipAddress: req.ip || null,
        userAgent: req.get("User-Agent") || null
      });

      res.status(201).json(labOrder);
    } catch (error) {
      console.error("Create lab order error:", error);
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Invalid input data", errors: error.errors });
      }
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Insurance claims management routes
  app.use("/api/insurance-claims", requireTenant);

  app.get("/api/insurance-claims", async (req, res) => {
    try {
      const { patientId } = req.query;
      const tenantId = req.tenant!.id;

      let claims;
      if (patientId) {
        claims = await storage.getInsuranceClaimsByPatient(patientId as string, tenantId);
      } else {
        claims = await storage.getInsuranceClaimsByTenant(tenantId);
      }

      res.json(claims);
    } catch (error) {
      console.error("Get insurance claims error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.post("/api/insurance-claims", requireRole(["billing_staff", "physician", "tenant_admin", "director"]), async (req, res) => {
    try {
      const requestData = { ...req.body };
      
      // Generate unique claim number if not provided
      if (!requestData.claimNumber) {
        requestData.claimNumber = `CLM-${Date.now()}-${Math.random().toString(36).substr(2, 5).toUpperCase()}`;
      }

      const claimData = insertInsuranceClaimSchema.parse({
        ...requestData,
        tenantId: req.tenant!.id
      });

      const claim = await storage.createInsuranceClaim(claimData);

      // Create audit log
      await storage.createAuditLog({
        tenantId: req.tenant!.id,
        userId: req.user!.id,
        entityType: "insurance_claim",
        entityId: claim.id,
        action: "create",
        previousData: null,
        newData: claim,
        ipAddress: req.ip || null,
        userAgent: req.get("User-Agent") || null
      });

      res.status(201).json(claim);
    } catch (error) {
      console.error("Create insurance claim error:", error);
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Invalid input data", errors: error.errors });
      }
      if (error.code === '23505' && error.constraint === 'insurance_claims_claim_number_unique') {
        return res.status(400).json({ message: "Claim number already exists. Please use a different claim number." });
      }
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.patch("/api/insurance-claims/:id", requireRole(["billing_staff", "physician", "tenant_admin", "director"]), async (req, res) => {
    try {
      const { id } = req.params;
      const updateData = { ...req.body };

      // Handle date fields properly
      if (updateData.submittedDate) {
        updateData.submittedDate = new Date(updateData.submittedDate);
      }
      if (updateData.processedDate) {
        updateData.processedDate = new Date(updateData.processedDate);
      }

      const updatedClaim = await storage.updateInsuranceClaim(id, updateData, req.tenant!.id);

      // Create audit log
      await storage.createAuditLog({
        tenantId: req.tenant!.id,
        userId: req.user!.id,
        entityType: "insurance_claim",
        entityId: id,
        action: "update",
        previousData: null,
        newData: updateData,
        ipAddress: req.ip || null,
        userAgent: req.get("User-Agent") || null
      });

      res.json(updatedClaim);
    } catch (error) {
      console.error("Update insurance claim error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Insurance Provider routes
  app.get("/api/insurance-providers", requireTenant, async (req, res) => {
    try {
      const providers = await storage.getInsuranceProviders(req.tenant!.id);
      res.json(providers);
    } catch (error) {
      console.error("Get insurance providers error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Patient Insurance routes
  app.get("/api/patient-insurance/:patientId", requireTenant, async (req, res) => {
    try {
      const { patientId } = req.params;
      const insuranceList = await storage.getPatientInsurance(patientId, req.tenant!.id);
      res.json(insuranceList);
    } catch (error) {
      console.error("Get patient insurance error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Service Pricing routes
  app.get("/api/service-prices", requireTenant, async (req, res) => {
    try {
      const servicePrices = await storage.getServicePrices(req.tenant!.id);
      res.json(servicePrices);
    } catch (error) {
      console.error("Get service prices error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.post("/api/service-prices", requireRole(["tenant_admin", "director", "billing_staff"]), async (req, res) => {
    try {
      const servicePriceData = insertServicePriceSchema.parse({
        ...req.body,
        tenantId: req.tenant!.id
      });

      const servicePrice = await storage.createServicePrice(servicePriceData);
      res.json(servicePrice);
    } catch (error) {
      console.error("Create service price error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.get("/api/service-prices/:id", requireTenant, async (req, res) => {
    try {
      const { id } = req.params;
      const servicePrice = await storage.getServicePrice(id, req.tenant!.id);
      
      if (!servicePrice) {
        return res.status(404).json({ message: "Service price not found" });
      }

      res.json(servicePrice);
    } catch (error) {
      console.error("Get service price error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Insurance Plan Coverage routes
  app.get("/api/insurance-plan-coverage", requireTenant, async (req, res) => {
    try {
      const coverages = await storage.getInsurancePlanCoverages(req.tenant!.id);
      res.json(coverages);
    } catch (error) {
      console.error("Get insurance plan coverages error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.post("/api/insurance-plan-coverage", requireRole(["tenant_admin", "director", "billing_staff"]), async (req, res) => {
    try {
      const coverageData = insertInsurancePlanCoverageSchema.parse({
        ...req.body,
        tenantId: req.tenant!.id
      });

      const coverage = await storage.createInsurancePlanCoverage(coverageData);
      res.json(coverage);
    } catch (error) {
      console.error("Create insurance plan coverage error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Pricing calculation endpoint
  app.post("/api/calculate-pricing", requireTenant, async (req, res) => {
    try {
      const { servicePriceId, insuranceProviderId, patientInsuranceId } = req.body;

      if (!servicePriceId || !insuranceProviderId || !patientInsuranceId) {
        return res.status(400).json({ 
          message: "servicePriceId, insuranceProviderId, and patientInsuranceId are required" 
        });
      }

      const pricing = await storage.calculateCopayAndInsuranceAmount(
        servicePriceId,
        insuranceProviderId, 
        patientInsuranceId,
        req.tenant!.id
      );

      res.json(pricing);
    } catch (error) {
      console.error("Calculate pricing error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Claim Line Items routes
  app.get("/api/claim-line-items/:claimId", requireTenant, async (req, res) => {
    try {
      const { claimId } = req.params;
      const lineItems = await storage.getClaimLineItems(claimId, req.tenant!.id);
      res.json(lineItems);
    } catch (error) {
      console.error("Get claim line items error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.post("/api/claim-line-items", requireRole(["billing_staff", "physician", "tenant_admin", "director"]), async (req, res) => {
    try {
      const lineItemData = insertClaimLineItemSchema.parse({
        ...req.body,
        tenantId: req.tenant!.id
      });

      const lineItem = await storage.createClaimLineItem(lineItemData);
      res.json(lineItem);
    } catch (error) {
      console.error("Create claim line item error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Dashboard metrics
  app.get("/api/dashboard/metrics", requireTenant, async (req, res) => {
    try {
      const tenantId = req.tenant?.id || req.user?.tenantId;
      if (!tenantId) {
        return res.status(400).json({ message: "Tenant context required" });
      }
      
      const metrics = await storage.getDashboardMetrics(tenantId);
      res.json(metrics);
    } catch (error) {
      console.error("Get dashboard metrics error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Audit logs
  app.get("/api/audit-logs", requireRole(["tenant_admin", "director", "super_admin"]), requireTenant, async (req, res) => {
    try {
      const { limit = "50", offset = "0" } = req.query;
      const auditLogs = await storage.getAuditLogs(
        req.tenant!.id, 
        parseInt(limit as string), 
        parseInt(offset as string)
      );
      res.json(auditLogs);
    } catch (error) {
      console.error("Get audit logs error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Platform metrics route for super admin
  app.get("/api/platform/metrics", authenticateToken, async (req, res) => {
    try {
      if (req.user.role !== 'super_admin') {
        return res.status(403).json({ message: "Access denied" });
      }

      const metrics = await storage.getPlatformMetrics();
      res.json(metrics);
    } catch (error) {
      console.error("Platform metrics error:", error);
      res.status(500).json({ message: "Failed to fetch platform metrics" });
    }
  });

  // Reports routes
  app.get("/api/reports", authenticateToken, requireTenant, async (req, res) => {
    try {
      const reports = await storage.getReportsByTenant(req.tenant.id);
      res.json(reports);
    } catch (error) {
      console.error("Reports fetch error:", error);
      res.status(500).json({ message: "Failed to fetch reports" });
    }
  });

  app.post("/api/reports", authenticateToken, requireTenant, async (req, res) => {
    try {
      const reportData = insertReportSchema.parse({
        ...req.body,
        tenantId: req.tenant.id,
        generatedBy: req.user.id,
        status: 'generating'
      });

      const report = await storage.createReport(reportData);

      // Create audit log
      await storage.createAuditLog({
        tenantId: req.tenant.id,
        userId: req.user.id,
        entityType: "report",
        entityId: report.id,
        action: "create",
        previousData: null,
        newData: { title: report.title, type: report.type },
        ipAddress: req.ip || null,
        userAgent: req.get("User-Agent") || null
      });

      // In a real implementation, you would trigger async report generation here
      // For now, we'll simulate completion
      setTimeout(async () => {
        try {
          await storage.updateReport(report.id, {
            status: 'completed',
            completedAt: new Date(),
            fileUrl: `/api/reports/${report.id}/download`
          }, req.tenant.id);
        } catch (error) {
          console.error("Report completion error:", error);
        }
      }, 3000);

      res.status(201).json(report);
    } catch (error) {
      console.error("Report creation error:", error);
      res.status(500).json({ message: "Failed to create report" });
    }
  });

  // Platform-wide report generation for super admin
  app.post("/api/platform/reports/generate", authenticateToken, async (req, res) => {
    try {
      console.log("Cross-tenant report - User:", req.user);
      
      if (req.user.role !== 'super_admin') {
        return res.status(403).json({ message: "Access denied. Super admin role required." });
      }

      const { targetTenantId, ...reportParams } = req.body;
      
      if (!targetTenantId) {
        return res.status(400).json({ message: "Target tenant ID is required for cross-tenant reports" });
      }

      // Verify target tenant exists
      const targetTenant = await storage.getTenant(targetTenantId);
      if (!targetTenant) {
        return res.status(404).json({ message: "Target tenant not found" });
      }

      const reportData = insertReportSchema.parse({
        ...reportParams,
        tenantId: targetTenantId,
        generatedBy: req.user.id,
        status: 'generating',
        parameters: { 
          ...reportParams.parameters, 
          crossTenantGeneration: true, 
          generatedByRole: 'super_admin' 
        }
      });

      const report = await storage.createReport(reportData);

      // Create audit log for both platform and target tenant
      await storage.createAuditLog({
        tenantId: req.user.tenantId, // Platform tenant
        userId: req.user.id,
        entityType: "cross_tenant_report",
        entityId: report.id,
        action: "create",
        previousData: null,
        newData: { 
          title: report.title, 
          type: report.type, 
          targetTenant: targetTenant.name,
          targetTenantId: targetTenantId 
        },
        ipAddress: req.ip || null,
        userAgent: req.get("User-Agent") || null
      });

      await storage.createAuditLog({
        tenantId: targetTenantId, // Target tenant
        userId: req.user.id,
        entityType: "report",
        entityId: report.id,
        action: "platform_generate",
        previousData: null,
        newData: { 
          title: report.title, 
          type: report.type, 
          generatedBy: 'platform_admin' 
        },
        ipAddress: req.ip || null,
        userAgent: req.get("User-Agent") || null
      });

      // Simulate async report generation
      setTimeout(async () => {
        try {
          await storage.updateReport(report.id, {
            status: 'completed',
            completedAt: new Date(),
            fileUrl: `/api/platform/reports/${report.id}/download`
          }, targetTenantId);
        } catch (error) {
          console.error("Cross-tenant report completion error:", error);
        }
      }, 4000);

      res.status(201).json(report);
    } catch (error) {
      console.error("Cross-tenant report creation error:", error);
      res.status(500).json({ message: "Failed to create cross-tenant report" });
    }
  });

  // Get users for a specific tenant (for super admin and tenant admin user management)
  app.get("/api/users/:tenantId", authenticateToken, requireTenant, async (req, res) => {
    try {
      const { tenantId } = req.params;
      
      // Super admin can view users from any tenant
      if (req.user?.role === 'super_admin') {
        const users = await storage.getUsersByTenant(tenantId);
        res.json(users);
      } else if ((req.user?.role === 'tenant_admin' || req.user?.role === 'director') && req.user.tenantId === tenantId) {
        // Tenant admin and director can view users from their own tenant
        const users = await storage.getUsersByTenant(tenantId);
        res.json(users);
      } else if (req.user?.tenantId === tenantId) {
        // Regular users can only view users from their own tenant (limited info)
        const users = await storage.getUsersByTenant(tenantId);
        res.json(users);
      } else {
        return res.status(403).json({ message: "Access denied. Cannot view users from this organization." });
      }
    } catch (error) {
      console.error("Get users error:", error);
      res.status(500).json({ message: "Failed to fetch users" });
    }
  });

  // Update user (for user management)
  app.patch("/api/users/:id", authenticateToken, async (req, res) => {
    try {
      const { id } = req.params;
      const updateData = req.body;
      
      // Get the user to check permissions
      const existingUser = await storage.getUser(id);
      if (!existingUser) {
        return res.status(404).json({ message: "User not found" });
      }

      // Check if user has permission to update this user
      const hasPermission = req.user.role === 'super_admin' || 
                           ((req.user.role === 'tenant_admin' || req.user.role === 'director') && existingUser.tenantId === req.user.tenantId) ||
                           (req.user.id === id); // User updating themselves

      if (!hasPermission) {
        return res.status(403).json({ message: "Access denied. Cannot update this user." });
      }

      // Prevent deactivation of super admin users
      if (existingUser.role === 'super_admin' && updateData.isActive === false) {
        return res.status(403).json({ message: "Cannot deactivate super admin users. This role is permanent for platform security." });
      }

      // Prevent users from deactivating themselves
      if (req.user.id === id && updateData.isActive === false) {
        return res.status(403).json({ message: "You cannot deactivate your own account." });
      }

      // Update the user
      const updatedUser = await storage.updateUser(id, updateData);
      
      // Create audit log
      await storage.createAuditLog({
        tenantId: existingUser.tenantId,
        userId: req.user.id || null,
        entityType: "user",
        entityId: id,
        action: "update",
        previousData: null,
        oldData: { isActive: existingUser.isActive, role: existingUser.role },
        newData: updateData,
        ipAddress: req.ip || null,
        userAgent: req.get("User-Agent") || null
      });

      res.json({
        message: "User updated successfully",
        user: {
          id: updatedUser.id,
          username: updatedUser.username,
          email: updatedUser.email,
          firstName: updatedUser.firstName,
          lastName: updatedUser.lastName,
          role: updatedUser.role,
          isActive: updatedUser.isActive,
          tenantId: updatedUser.tenantId
        }
      });
    } catch (error) {
      console.error("User update error:", error);
      res.status(500).json({ message: "Failed to update user" });
    }
  });

  // Create new user (for tenant admin user management)
  app.post("/api/users", authenticateToken, requireTenant, async (req, res) => {
    try {
      const { username, email, password, firstName, lastName, role } = req.body;
      
      // Validate required fields
      if (!username || !email || !password || !firstName || !lastName || !role) {
        return res.status(400).json({ message: "All fields are required" });
      }

      // Check permissions - only super admin, tenant admin, and director can create users
      if (req.user?.role !== 'super_admin' && req.user?.role !== 'tenant_admin' && req.user?.role !== 'director') {
        return res.status(403).json({ message: "Access denied. Admin privileges required to create users." });
      }

      // Tenant admin can only create users in their own organization
      const targetTenantId = req.user.role === 'super_admin' ? (req.body.tenantId || req.user.tenantId) : req.user.tenantId;

      // Validate that tenant admin and director cannot create super admin or other admin users
      if (req.user?.role === 'tenant_admin' || req.user?.role === 'director') {
        if (role === 'super_admin' || role === 'tenant_admin' || role === 'director') {
          return res.status(403).json({ message: "Tenant admins and directors cannot create admin-level users. Only clinical and operational staff roles are allowed." });
        }
      }

      // Check if username or email already exists in this tenant
      const existingUserByUsername = await storage.getUserByUsername(username, targetTenantId);
      if (existingUserByUsername) {
        return res.status(400).json({ message: "Username already exists in this organization" });
      }

      const existingUserByEmail = await storage.getUserByEmail(email, targetTenantId);
      if (existingUserByEmail) {
        return res.status(400).json({ message: "Email already exists in this organization" });
      }

      // Hash password
      const hashedPassword = await bcrypt.hash(password, 10);

      // Create user
      const newUser = await storage.createUser({
        username,
        email,
        password: hashedPassword,
        firstName,
        lastName,
        role: role as any, // Cast to UserRole type
        tenantId: targetTenantId,
        isActive: true,
        createdAt: new Date(),
        updatedAt: new Date()
      });

      // Create audit log
      await storage.createAuditLog({
        tenantId: targetTenantId,
        userId: req.user?.userId || null,
        entityType: "user",
        entityId: newUser.id,
        action: "create",
        previousData: null,
        newData: { 
          username, 
          email, 
          firstName, 
          lastName, 
          role,
          tenantId: targetTenantId
        },
        ipAddress: req.ip || null,
        userAgent: req.get("User-Agent") || null
      });

      res.status(201).json({
        message: "User created successfully",
        user: {
          id: newUser.id,
          username: newUser.username,
          email: newUser.email,
          firstName: newUser.firstName,
          lastName: newUser.lastName,
          role: newUser.role,
          isActive: newUser.isActive,
          tenantId: newUser.tenantId
        }
      });
    } catch (error) {
      console.error("User creation error:", error);
      res.status(500).json({ message: "Failed to create user" });
    }
  });

  // Get all reports across platform for super admin
  app.get("/api/platform/reports", authenticateToken, async (req, res) => {
    try {
      if (req.user.role !== 'super_admin') {
        return res.status(403).json({ message: "Access denied. Super admin role required." });
      }

      const reports = await storage.getAllReports();
      res.json(reports);
    } catch (error) {
      console.error("Platform reports fetch error:", error);
      res.status(500).json({ message: "Failed to fetch platform reports" });
    }
  });

  // Download report endpoint
  app.get("/api/reports/:id/download", authenticateToken, async (req, res) => {
    try {
      const { id } = req.params;
      const report = await storage.getReport(id, req.tenant?.id || '');
      
      if (!report) {
        return res.status(404).json({ message: "Report not found" });
      }

      if (report.status !== 'completed') {
        return res.status(400).json({ message: "Report is not ready for download" });
      }

      // Generate mock report content based on type and format
      const reportContent = generateReportContent(report);
      const filename = `${report.title.replace(/[^a-zA-Z0-9]/g, '_')}.${report.format}`;

      // Set appropriate headers based on format
      switch (report.format) {
        case 'pdf':
          res.setHeader('Content-Type', 'application/pdf');
          break;
        case 'excel':
          res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');
          break;
        case 'csv':
          res.setHeader('Content-Type', 'text/csv');
          break;
        default:
          res.setHeader('Content-Type', 'application/octet-stream');
      }

      res.setHeader('Content-Disposition', `attachment; filename="${filename}"`);
      res.send(reportContent);

    } catch (error) {
      console.error("Report download error:", error);
      res.status(500).json({ message: "Failed to download report" });
    }
  });

  // Platform download endpoint for cross-tenant reports
  app.get("/api/platform/reports/:id/download", authenticateToken, async (req, res) => {
    try {
      if (req.user.role !== 'super_admin') {
        return res.status(403).json({ message: "Access denied. Super admin role required." });
      }

      const { id } = req.params;
      const reports = await storage.getAllReports();
      const report = reports.find(r => r.id === id);
      
      if (!report) {
        return res.status(404).json({ message: "Report not found" });
      }

      if (report.status !== 'completed') {
        return res.status(400).json({ message: "Report is not ready for download" });
      }

      // Generate mock report content
      const reportContent = generateReportContent(report);
      const filename = `${report.title.replace(/[^a-zA-Z0-9]/g, '_')}.${report.format}`;

      // Set headers
      switch (report.format) {
        case 'pdf':
          res.setHeader('Content-Type', 'application/pdf');
          break;
        case 'excel':
          res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');
          break;
        case 'csv':
          res.setHeader('Content-Type', 'text/csv');
          break;
        default:
          res.setHeader('Content-Type', 'application/octet-stream');
      }

      res.setHeader('Content-Disposition', `attachment; filename="${filename}"`);
      res.send(reportContent);

    } catch (error) {
      console.error("Platform report download error:", error);
      res.status(500).json({ message: "Failed to download report" });
    }
  });

  // ==================== MULTILINGUAL COMMUNICATION ROUTES ====================

  // Medical Communications routes
  app.get("/api/medical-communications", authenticateToken, requireTenant, async (req, res) => {
    try {
      const communications = await storage.getMedicalCommunicationsByTenant(req.user.tenantId);
      res.json(communications);
    } catch (error) {
      console.error("Failed to fetch communications:", error);
      res.status(500).json({ message: "Failed to fetch communications" });
    }
  });

  app.get("/api/medical-communications/:id", authenticateToken, requireTenant, async (req, res) => {
    try {
      const { id } = req.params;
      const communication = await storage.getMedicalCommunication(id, req.user.tenantId);
      
      if (!communication) {
        return res.status(404).json({ message: "Communication not found" });
      }
      
      res.json(communication);
    } catch (error) {
      console.error("Failed to fetch communication:", error);
      res.status(500).json({ message: "Failed to fetch communication" });
    }
  });

  app.post("/api/medical-communications", authenticateToken, requireTenant, requireRole(["physician", "nurse", "tenant_admin", "director", "super_admin"]), async (req, res) => {
    try {
      const validatedData = insertMedicalCommunicationSchema.parse({
        ...req.body,
        tenantId: req.user.tenantId,
        senderId: req.user.id,
      });

      const communication = await storage.createMedicalCommunication(validatedData);

      // Create audit log
      await storage.createAuditLog({
        tenantId: req.user.tenantId,
        userId: req.user.id,
        entityType: "medical_communication",
        entityId: communication.id,
        action: "CREATE",
        previousData: null,
        newData: communication,
        ipAddress: req.ip || null,
        userAgent: req.get('User-Agent') || null
      });

      res.status(201).json(communication);
    } catch (error) {
      console.error("Failed to create communication:", error);
      res.status(500).json({ message: "Failed to create communication" });
    }
  });

  app.patch("/api/medical-communications/:id", authenticateToken, requireTenant, async (req, res) => {
    try {
      const { id } = req.params;
      const updates = req.body;

      const communication = await storage.updateMedicalCommunication(id, updates, req.user.tenantId);
      
      if (!communication) {
        return res.status(404).json({ message: "Communication not found" });
      }

      // Create audit log
      await storage.createAuditLog({
        tenantId: req.user.tenantId,
        userId: req.user.id,
        entityType: "medical_communication",
        entityId: communication.id,
        action: "UPDATE",
        previousData: null,
        newData: communication,
        ipAddress: req.ip || null,
        userAgent: req.get('User-Agent') || null
      });

      res.json(communication);
    } catch (error) {
      console.error("Failed to update communication:", error);
      res.status(500).json({ message: "Failed to update communication" });
    }
  });

  // Communication Translations routes
  app.get("/api/communication-translations/:communicationId", authenticateToken, requireTenant, async (req, res) => {
    try {
      const { communicationId } = req.params;
      const translations = await storage.getCommunicationTranslations(communicationId);
      res.json(translations);
    } catch (error) {
      console.error("Failed to fetch translations:", error);
      res.status(500).json({ message: "Failed to fetch translations" });
    }
  });

  app.post("/api/communication-translations", authenticateToken, requireTenant, async (req, res) => {
    try {
      const validatedData = insertCommunicationTranslationSchema.parse(req.body);
      const translation = await storage.createCommunicationTranslation(validatedData);

      // Create audit log
      await storage.createAuditLog({
        tenantId: req.user.tenantId,
        userId: req.user.id,
        entityType: "communication_translation",
        entityId: translation.id,
        action: "CREATE",
        previousData: null,
        newData: translation,
        ipAddress: req.ip || null,
        userAgent: req.get('User-Agent') || null
      });

      res.status(201).json(translation);
    } catch (error) {
      console.error("Failed to create translation:", error);
      res.status(500).json({ message: "Failed to create translation" });
    }
  });

  // Supported Languages routes
  app.get("/api/supported-languages", authenticateToken, requireTenant, async (req, res) => {
    try {
      const languages = await storage.getSupportedLanguages(req.user.tenantId);
      res.json(languages);
    } catch (error) {
      console.error("Failed to fetch languages:", error);
      res.status(500).json({ message: "Failed to fetch languages" });
    }
  });

  app.post("/api/supported-languages", authenticateToken, requireTenant, requireRole(["tenant_admin", "director", "super_admin"]), async (req, res) => {
    try {
      const validatedData = insertSupportedLanguageSchema.parse({
        ...req.body,
        tenantId: req.user.tenantId,
      });

      const language = await storage.createSupportedLanguage(validatedData);

      // Create audit log
      await storage.createAuditLog({
        tenantId: req.user.tenantId,
        userId: req.user.id,
        entityType: "supported_language",
        entityId: language.id,
        action: "CREATE",
        previousData: null,
        newData: language,
        ipAddress: req.ip || null,
        userAgent: req.get('User-Agent') || null
      });

      res.status(201).json(language);
    } catch (error) {
      console.error("Failed to create language:", error);
      res.status(500).json({ message: "Failed to create language" });
    }
  });

  app.patch("/api/supported-languages/:id", authenticateToken, requireTenant, requireRole(["tenant_admin", "director", "super_admin"]), async (req, res) => {
    try {
      const { id } = req.params;
      const updates = req.body;

      const language = await storage.updateSupportedLanguage(id, updates, req.user.tenantId);
      
      if (!language) {
        return res.status(404).json({ message: "Language not found" });
      }

      // Create audit log
      await storage.createAuditLog({
        tenantId: req.user.tenantId,
        userId: req.user.id,
        entityType: "supported_language",
        entityId: language.id,
        action: "UPDATE",
        previousData: null,
        newData: language,
        ipAddress: req.ip || null,
        userAgent: req.get('User-Agent') || null
      });

      res.json(language);
    } catch (error) {
      console.error("Failed to update language:", error);
      res.status(500).json({ message: "Failed to update language" });
    }
  });

  // Medical Phrases routes
  app.get("/api/medical-phrases", authenticateToken, requireTenant, async (req, res) => {
    try {
      const { category } = req.query;
      const phrases = await storage.getMedicalPhrases(req.user.tenantId, category as string);
      res.json(phrases);
    } catch (error) {
      console.error("Failed to fetch phrases:", error);
      res.status(500).json({ message: "Failed to fetch phrases" });
    }
  });

  app.post("/api/medical-phrases", authenticateToken, requireTenant, requireRole(["physician", "nurse", "tenant_admin", "director", "super_admin"]), async (req, res) => {
    try {
      const validatedData = insertMedicalPhraseSchema.parse({
        ...req.body,
        tenantId: req.user.tenantId,
      });

      const phrase = await storage.createMedicalPhrase(validatedData);

      // Create audit log
      await storage.createAuditLog({
        tenantId: req.user.tenantId,
        userId: req.user.id,
        entityType: "medical_phrase",
        entityId: phrase.id,
        action: "CREATE",
        previousData: null,
        newData: phrase,
        ipAddress: req.ip || null,
        userAgent: req.get('User-Agent') || null
      });

      res.status(201).json(phrase);
    } catch (error) {
      console.error("Failed to create phrase:", error);
      res.status(500).json({ message: "Failed to create phrase" });
    }
  });

  // Phrase Translations routes
  app.get("/api/phrase-translations/:phraseId", authenticateToken, requireTenant, async (req, res) => {
    try {
      const { phraseId } = req.params;
      const translations = await storage.getPhraseTranslations(phraseId);
      res.json(translations);
    } catch (error) {
      console.error("Failed to fetch phrase translations:", error);
      res.status(500).json({ message: "Failed to fetch phrase translations" });
    }
  });

  app.post("/api/phrase-translations", authenticateToken, requireTenant, requireRole(["physician", "nurse", "tenant_admin", "director", "super_admin"]), async (req, res) => {
    try {
      const validatedData = insertPhraseTranslationSchema.parse({
        ...req.body,
        translatedBy: req.user.id,
      });

      const translation = await storage.createPhraseTranslation(validatedData);

      // Create audit log
      await storage.createAuditLog({
        tenantId: req.user.tenantId,
        userId: req.user.id,
        entityType: "phrase_translation",
        entityId: translation.id,
        action: "CREATE",
        previousData: null,
        newData: translation,
        ipAddress: req.ip || null,
        userAgent: req.get('User-Agent') || null
      });

      res.status(201).json(translation);
    } catch (error) {
      console.error("Failed to create phrase translation:", error);
      res.status(500).json({ message: "Failed to create phrase translation" });
    }
  });

  // Laboratory Management Routes
  app.get("/api/laboratories", authenticateToken, requireTenant, async (req, res) => {
    try {
      const laboratories = await storage.getLaboratoriesByTenant(req.tenantId!);
      res.json(laboratories);
    } catch (error) {
      console.error("Error fetching laboratories:", error);
      res.status(500).json({ message: "Failed to fetch laboratories" });
    }
  });

  app.get("/api/laboratories/active", authenticateToken, requireTenant, async (req, res) => {
    try {
      const laboratories = await storage.getActiveLaboratoriesByTenant(req.tenantId!);
      res.json(laboratories);
    } catch (error) {
      console.error("Error fetching active laboratories:", error);
      res.status(500).json({ message: "Failed to fetch active laboratories" });
    }
  });

  app.post("/api/laboratories", authenticateToken, requireRole(["tenant_admin", "director", "super_admin"]), requireTenant, async (req, res) => {
    try {
      const laboratoryData = insertLaboratorySchema.parse({
        ...req.body,
        tenantId: req.tenantId
      });

      const laboratory = await storage.createLaboratory(laboratoryData);

      // Create audit log
      await storage.createAuditLog({
        tenantId: req.tenantId!,
        userId: req.userId!,
        entityType: "laboratory",
        entityId: laboratory.id,
        action: "create",
        previousData: null,
        newData: laboratory,
        ipAddress: req.ip || null,
        userAgent: req.get("User-Agent") || null
      });

      res.status(201).json(laboratory);
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Invalid laboratory data", errors: error.errors });
      }
      console.error("Error creating laboratory:", error);
      res.status(500).json({ message: "Failed to create laboratory" });
    }
  });

  // Lab Results Routes
  app.get("/api/lab-results", authenticateToken, requireTenant, async (req, res) => {
    try {
      const labResults = await storage.getLabResultsByTenant(req.tenantId!);
      res.json(labResults);
    } catch (error) {
      console.error("Error fetching lab results:", error);
      res.status(500).json({ message: "Failed to fetch lab results" });
    }
  });

  app.get("/api/lab-results/patient/:patientId", authenticateToken, requireTenant, async (req, res) => {
    try {
      const labResults = await storage.getLabResultsByPatient(req.params.patientId, req.tenantId!);
      res.json(labResults);
    } catch (error) {
      console.error("Error fetching patient lab results:", error);
      res.status(500).json({ message: "Failed to fetch patient lab results" });
    }
  });

  app.get("/api/lab-results/order/:labOrderId", authenticateToken, requireTenant, async (req, res) => {
    try {
      const labResults = await storage.getLabResultsByOrder(req.params.labOrderId, req.tenantId!);
      res.json(labResults);
    } catch (error) {
      console.error("Error fetching lab order results:", error);
      res.status(500).json({ message: "Failed to fetch lab order results" });
    }
  });

  app.post("/api/lab-results", authenticateToken, requireRole(["lab_technician", "physician", "tenant_admin", "director", "super_admin"]), requireTenant, async (req, res) => {
    try {
      const labResultData = insertLabResultSchema.parse({
        ...req.body,
        tenantId: req.tenantId
      });

      const labResult = await storage.createLabResult(labResultData);

      // Create audit log
      await storage.createAuditLog({
        tenantId: req.tenantId!,
        userId: req.userId!,
        entityType: "lab_result",
        entityId: labResult.id,
        action: "create",
        previousData: null,
        newData: labResult,
        ipAddress: req.ip || null,
        userAgent: req.get("User-Agent") || null
      });

      res.status(201).json(labResult);
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Invalid lab result data", errors: error.errors });
      }
      console.error("Error creating lab result:", error);
      res.status(500).json({ message: "Failed to create lab result" });
    }
  });

  // Lab Order Assignment Routes
  app.post("/api/lab-order-assignments", authenticateToken, requireRole(["physician", "nurse", "lab_technician", "tenant_admin", "director", "super_admin"]), requireTenant, async (req, res) => {
    try {
      const assignmentData = insertLabOrderAssignmentSchema.parse({
        ...req.body,
        tenantId: req.tenantId,
        assignedBy: req.userId
      });

      const assignment = await storage.createLabOrderAssignment(assignmentData);

      // Create audit log
      await storage.createAuditLog({
        tenantId: req.tenantId!,
        userId: req.userId!,
        entityType: "lab_order_assignment",
        entityId: assignment.id,
        action: "create",
        previousData: null,
        newData: assignment,
        ipAddress: req.ip || null,
        userAgent: req.get("User-Agent") || null
      });

      res.status(201).json(assignment);
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Invalid assignment data", errors: error.errors });
      }
      console.error("Error creating lab order assignment:", error);
      res.status(500).json({ message: "Failed to create lab order assignment" });
    }
  });

  // External Lab Integration Endpoint for receiving results
  app.post("/api/external-lab/results", async (req, res) => {
    try {
      const { 
        externalLabId, 
        labOrderId, 
        results, 
        laboratoryApiKey 
      } = req.body;

      // Find laboratory by API key across all tenants
      const allTenants = await storage.getAllTenants();
      let laboratory;
      
      for (const tenant of allTenants) {
        const labs = await storage.getLaboratoriesByTenant(tenant.id);
        laboratory = labs.find(lab => lab.apiKey === laboratoryApiKey);
        if (laboratory) break;
      }

      if (!laboratory) {
        return res.status(401).json({ message: "Invalid laboratory API key" });
      }

      // Process each result
      for (const result of results) {
        const labResultData = insertLabResultSchema.parse({
          labOrderId: labOrderId,
          laboratoryId: laboratory.id,
          tenantId: laboratory.tenantId,
          patientId: result.patientId,
          testName: result.testName,
          result: result.result,
          normalRange: result.normalRange,
          unit: result.unit,
          status: 'completed',
          abnormalFlag: result.abnormalFlag,
          notes: result.notes,
          performedBy: result.performedBy,
          completedAt: new Date(result.completedAt),
          reportedAt: new Date(),
          externalLabId: externalLabId,
          rawData: result.rawData
        });

        await storage.createLabResult(labResultData);
      }

      // Update the lab order assignment status
      const assignment = await storage.getLabOrderAssignmentByOrder(labOrderId, laboratory.tenantId);
      if (assignment) {
        await storage.updateLabOrderAssignment(assignment.id, {
          status: 'completed',
          actualCompletionTime: new Date()
        }, laboratory.tenantId);
      }

      res.json({ message: "Results received successfully", processed: results.length });
    } catch (error) {
      console.error("Error processing external lab results:", error);
      res.status(500).json({ message: "Failed to process lab results" });
    }
  });

  // Laboratory application routes (external lab registration) - Public endpoint
  app.post("/api/laboratory-applications", async (req, res) => {
    try {
      const applicationData = insertLaboratoryApplicationSchema.parse(req.body);
      
      const application = await storage.createLaboratoryApplication(applicationData);
      
      res.status(201).json(application);
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Invalid application data", errors: error.errors });
      }
      console.error("Error creating laboratory application:", error);
      res.status(500).json({ message: "Failed to create laboratory application" });
    }
  });

  app.get("/api/laboratory-applications", authenticateToken, requireRole(["super_admin"]), async (req, res) => {
    try {
      const status = req.query.status as string;
      const applications = status 
        ? await storage.getLaboratoryApplicationsByStatus(status)
        : await storage.getAllLaboratoryApplications();
      res.json(applications);
    } catch (error) {
      console.error("Error fetching laboratory applications:", error);
      res.status(500).json({ message: "Failed to fetch laboratory applications" });
    }
  });

  app.post("/api/laboratory-applications/:id/approve", authenticateToken, requireRole(["super_admin"]), async (req, res) => {
    try {
      const { reviewNotes } = req.body;
      const result = await storage.approveLaboratoryApplication(req.params.id, req.userId!, reviewNotes);
      
      if (!result) {
        return res.status(404).json({ message: "Laboratory application not found" });
      }

      res.json(result);
    } catch (error) {
      console.error("Error approving laboratory application:", error);
      res.status(500).json({ message: "Failed to approve laboratory application" });
    }
  });

  app.post("/api/laboratory-applications/:id/reject", authenticateToken, requireRole(["super_admin"]), async (req, res) => {
    try {
      const { reviewNotes } = req.body;
      
      if (!reviewNotes) {
        return res.status(400).json({ message: "Review notes are required for rejection" });
      }

      const application = await storage.rejectLaboratoryApplication(req.params.id, req.userId!, reviewNotes);
      
      if (!application) {
        return res.status(404).json({ message: "Laboratory application not found" });
      }

      res.json(application);
    } catch (error) {
      console.error("Error rejecting laboratory application:", error);
      res.status(500).json({ message: "Failed to reject laboratory application" });
    }
  });

  // Vital Signs routes
  app.get("/api/vital-signs", authenticateToken, requireTenant, async (req, res) => {
    try {
      const vitalSigns = await storage.getVitalSignsByTenant(req.tenantId!);
      res.json(vitalSigns);
    } catch (error) {
      console.error("Error fetching vital signs:", error);
      res.status(500).json({ message: "Failed to fetch vital signs" });
    }
  });

  app.get("/api/vital-signs/patient/:patientId", authenticateToken, requireTenant, async (req, res) => {
    try {
      const vitalSigns = await storage.getVitalSignsByPatient(req.params.patientId, req.tenantId!);
      res.json(vitalSigns);
    } catch (error) {
      console.error("Error fetching patient vital signs:", error);
      res.status(500).json({ message: "Failed to fetch patient vital signs" });
    }
  });

  app.get("/api/vital-signs/appointment/:appointmentId", authenticateToken, requireTenant, async (req, res) => {
    try {
      const vitalSigns = await storage.getVitalSignsByAppointment(req.params.appointmentId, req.tenantId!);
      res.json(vitalSigns);
    } catch (error) {
      console.error("Error fetching appointment vital signs:", error);
      res.status(500).json({ message: "Failed to fetch appointment vital signs" });
    }
  });

  app.post("/api/vital-signs", authenticateToken, requireTenant, requireRole(["super_admin", "tenant_admin", "doctor", "nurse", "receptionist"]), async (req, res) => {
    try {
      const validatedData = insertVitalSignsSchema.parse({
        ...req.body,
        tenantId: req.tenantId,
        recordedBy: req.user?.id
      });

      const vitalSigns = await storage.createVitalSigns(validatedData);

      // If checkInId is provided, link the vital signs to the check-in record
      if (req.body.checkInId) {
        await storage.updatePatientCheckIn(req.body.checkInId, {
          vitalSignsId: vitalSigns.id
        }, req.tenantId!);
      }

      // Create audit log
      await storage.createAuditLog({
        userId: req.user?.id!,
        tenantId: req.tenantId!,
        action: "vital_signs_created",
        previousData: null,
        entityType: "vital_signs",
        entityId: vitalSigns.id,
        details: { patientId: vitalSigns.patientId, appointmentId: vitalSigns.appointmentId, checkInId: req.body.checkInId }
      });

      res.status(201).json(vitalSigns);
    } catch (error) {
      console.error("Error creating vital signs:", error);
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Validation error", errors: error.errors });
      }
      res.status(500).json({ message: "Failed to create vital signs" });
    }
  });

  app.patch("/api/vital-signs/:id", authenticateToken, requireTenant, requireRole(["super_admin", "tenant_admin", "doctor", "nurse", "receptionist"]), async (req, res) => {
    try {
      const vitalSigns = await storage.updateVitalSigns(req.params.id, req.body, req.tenantId!);
      
      if (!vitalSigns) {
        return res.status(404).json({ message: "Vital signs not found" });
      }

      // Create audit log
      await storage.createAuditLog({
        userId: req.userId!,
        tenantId: req.tenantId!,
        action: "vital_signs_updated",
        previousData: null,
        resourceType: "vital_signs",
        resourceId: vitalSigns.id,
        details: { changes: req.body }
      });

      res.json(vitalSigns);
    } catch (error) {
      console.error("Error updating vital signs:", error);
      res.status(500).json({ message: "Failed to update vital signs" });
    }
  });

  // Visit Summary routes
  app.get("/api/visit-summaries", authenticateToken, requireTenant, async (req, res) => {
    try {
      const visitSummaries = await storage.getVisitSummariesByTenant(req.tenantId!);
      res.json(visitSummaries);
    } catch (error) {
      console.error("Error fetching visit summaries:", error);
      res.status(500).json({ message: "Failed to fetch visit summaries" });
    }
  });

  app.get("/api/visit-summaries/patient/:patientId", authenticateToken, requireTenant, async (req, res) => {
    try {
      const visitSummaries = await storage.getVisitSummariesByPatient(req.params.patientId, req.tenantId!);
      res.json(visitSummaries);
    } catch (error) {
      console.error("Error fetching patient visit summaries:", error);
      res.status(500).json({ message: "Failed to fetch patient visit summaries" });
    }
  });

  app.get("/api/visit-summaries/provider/:providerId", authenticateToken, requireTenant, async (req, res) => {
    try {
      const visitSummaries = await storage.getVisitSummariesByProvider(req.params.providerId, req.tenantId!);
      res.json(visitSummaries);
    } catch (error) {
      console.error("Error fetching provider visit summaries:", error);
      res.status(500).json({ message: "Failed to fetch provider visit summaries" });
    }
  });

  app.get("/api/visit-summaries/appointment/:appointmentId", authenticateToken, requireTenant, async (req, res) => {
    try {
      const visitSummary = await storage.getVisitSummaryByAppointment(req.params.appointmentId, req.tenantId!);
      res.json(visitSummary);
    } catch (error) {
      console.error("Error fetching appointment visit summary:", error);
      res.status(500).json({ message: "Failed to fetch appointment visit summary" });
    }
  });

  app.post("/api/visit-summaries", authenticateToken, requireTenant, requireRole(["super_admin", "tenant_admin", "doctor", "nurse"]), async (req, res) => {
    try {
      const validatedData = insertVisitSummarySchema.parse({
        ...req.body,
        tenantId: req.tenantId,
        providerId: req.userId
      });

      const visitSummary = await storage.createVisitSummary(validatedData);

      // Create audit log
      await storage.createAuditLog({
        userId: req.userId!,
        tenantId: req.tenantId!,
        action: "visit_summary_created",
        previousData: null,
        resourceType: "visit_summary",
        resourceId: visitSummary.id,
        details: { patientId: visitSummary.patientId, appointmentId: visitSummary.appointmentId }
      });

      res.status(201).json(visitSummary);
    } catch (error) {
      console.error("Error creating visit summary:", error);
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Validation error", errors: error.errors });
      }
      res.status(500).json({ message: "Failed to create visit summary" });
    }
  });

  app.patch("/api/visit-summaries/:id", authenticateToken, requireTenant, requireRole(["super_admin", "tenant_admin", "doctor", "nurse"]), async (req, res) => {
    try {
      const visitSummary = await storage.updateVisitSummary(req.params.id, req.body, req.tenantId!);
      
      if (!visitSummary) {
        return res.status(404).json({ message: "Visit summary not found" });
      }

      // Create audit log
      await storage.createAuditLog({
        userId: req.userId!,
        tenantId: req.tenantId!,
        action: "visit_summary_updated",
        previousData: null,
        resourceType: "visit_summary",
        resourceId: visitSummary.id,
        details: { changes: req.body }
      });

      res.json(visitSummary);
    } catch (error) {
      console.error("Error updating visit summary:", error);
      res.status(500).json({ message: "Failed to update visit summary" });
    }
  });

  // AI Health Recommendations routes
  app.get("/api/health-recommendations/patient/:patientId", authenticateToken, requireTenant, async (req, res) => {
    try {
      const { patientId } = req.params;
      const { tenantId } = req.user;
      
      const recommendations = await storage.getHealthRecommendationsByPatient(patientId, tenantId);
      res.json(recommendations);
    } catch (error) {
      console.error("Error fetching health recommendations:", error);
      res.status(500).json({ message: "Failed to fetch health recommendations" });
    }
  });

  app.get("/api/health-recommendations/patient/:patientId/active", authenticateToken, requireTenant, async (req, res) => {
    try {
      const { patientId } = req.params;
      const { tenantId } = req.user;
      
      const recommendations = await storage.getActiveHealthRecommendationsByPatient(patientId, tenantId);
      res.json(recommendations);
    } catch (error) {
      console.error("Error fetching active health recommendations:", error);
      res.status(500).json({ message: "Failed to fetch active health recommendations" });
    }
  });

  app.post("/api/health-recommendations", authenticateToken, requireTenant, async (req, res) => {
    try {
      const { tenantId, userId } = req.user;
      const validatedData = insertHealthRecommendationSchema.parse({
        ...req.body,
        tenantId
      });
      
      const recommendation = await storage.createHealthRecommendation(validatedData);
      res.status(201).json(recommendation);
    } catch (error) {
      console.error("Error creating health recommendation:", error);
      res.status(500).json({ message: "Failed to create health recommendation" });
    }
  });

  app.patch("/api/health-recommendations/:id/acknowledge", authenticateToken, requireTenant, async (req, res) => {
    try {
      const { id } = req.params;
      const { tenantId, userId } = req.user;
      
      const recommendation = await storage.acknowledgeHealthRecommendation(id, userId, tenantId);
      if (!recommendation) {
        return res.status(404).json({ message: "Health recommendation not found" });
      }
      
      res.json(recommendation);
    } catch (error) {
      console.error("Error acknowledging health recommendation:", error);
      res.status(500).json({ message: "Failed to acknowledge health recommendation" });
    }
  });

  // AI Health Analysis routes
  app.get("/api/health-analyses/patient/:patientId", authenticateToken, requireTenant, async (req, res) => {
    try {
      const { patientId } = req.params;
      const { tenantId } = req.user;
      
      const analyses = await storage.getHealthAnalysesByPatient(patientId, tenantId);
      res.json(analyses);
    } catch (error) {
      console.error("Error fetching health analyses:", error);
      res.status(500).json({ message: "Failed to fetch health analyses" });
    }
  });

  app.get("/api/health-analyses/patient/:patientId/latest", authenticateToken, requireTenant, async (req, res) => {
    try {
      const { patientId } = req.params;
      const { tenantId } = req.user;
      
      const analysis = await storage.getLatestHealthAnalysis(patientId, tenantId);
      if (!analysis) {
        return res.status(404).json({ message: "No health analysis found for this patient" });
      }
      
      res.json(analysis);
    } catch (error) {
      console.error("Error fetching latest health analysis:", error);
      res.status(500).json({ message: "Failed to fetch latest health analysis" });
    }
  });

  app.post("/api/health-analyses/generate/:patientId", authenticateToken, requireTenant, requireRole(['physician', 'nurse', 'tenant_admin', 'super_admin']), async (req, res) => {
    try {
      console.log("Health analysis generation started for patient:", req.params.patientId);
      const { patientId } = req.params;
      const { tenantId, userId } = req.user;
      
      // Get patient data
      const patient = await storage.getPatient(patientId, tenantId);
      if (!patient) {
        return res.status(404).json({ message: "Patient not found" });
      }
      
      // Get vital signs (latest 10 records)
      const vitalSigns = await storage.getVitalSignsByPatient(patientId, tenantId);
      const recentVitalSigns = vitalSigns.slice(0, 10);
      
      // Get recent appointments (latest 5)
      const appointments = await storage.getAppointmentsByPatient(patientId, tenantId);
      const recentAppointments = appointments.slice(0, 5);
      
      // Get lab results (latest 10 records)
      const labResults = await storage.getLabResultsByPatient(patientId, tenantId);
      const recentLabResults = labResults.slice(0, 10);
      
      console.log(`Patient data summary: Vital signs: ${recentVitalSigns.length}, Appointments: ${recentAppointments.length}, Lab results: ${recentLabResults.length}`);
      
      if (recentVitalSigns.length === 0 && recentLabResults.length === 0) {
        return res.status(400).json({ 
          message: "No vital signs or lab results data available for health analysis. Please record vital signs or lab results first." 
        });
      }
      
      // Generate AI health analysis
      console.log("Generating AI health analysis...");
      // Try Gemini first, fall back to OpenAI system if needed
      let analysisResult;
      try {
        if (process.env.GEMINI_API_KEY) {
          console.log("Using Gemini AI for health analysis...");
          analysisResult = await geminiHealthAnalyzer.analyzePatientHealth(
            patient,
            recentVitalSigns,
            recentAppointments,
            recentLabResults
          );
        } else {
          throw new Error("Gemini API key not available, using fallback");
        }
      } catch (error) {
        console.log("Falling back to intelligent analysis system...");
        analysisResult = await aiHealthAnalyzer.analyzePatientHealth(
          patient,
          recentVitalSigns,
          recentAppointments,
          recentLabResults
        );
      }
      console.log("AI analysis completed successfully");
      
      // Save health analysis to database
      const healthAnalysis = await storage.createHealthAnalysis({
        tenantId,
        patientId,
        overallHealthScore: analysisResult.overallHealthScore,
        riskFactors: analysisResult.riskFactors,
        trends: analysisResult.trends,
        nextAppointmentSuggestion: analysisResult.nextAppointmentSuggestion,
        analysisData: analysisResult,
        confidence: 0.85 // Default confidence score
      });
      
      // Save individual recommendations
      const savedRecommendations = [];
      for (const rec of analysisResult.recommendations) {
        const recommendation = await storage.createHealthRecommendation({
          tenantId,
          patientId,
          type: rec.type,
          priority: rec.priority,
          title: rec.title,
          description: rec.description,
          recommendations: rec.recommendations,
          reasoning: rec.reasoning,
          followUpRequired: rec.followUpRequired
        });
        savedRecommendations.push(recommendation);
      }
      
      // Log audit trail
      await storage.createAuditLog({
        tenantId,
        userId,
        entityType: 'health_analysis',
        entityId: healthAnalysis.id,
        action: 'generate',
        newData: { 
          patientId,
          analysisScore: analysisResult.overallHealthScore,
          recommendationsCount: savedRecommendations.length
        },
        ipAddress: req.ip || null,
        userAgent: req.get("User-Agent") || null
      });
      
      res.json({
        analysis: healthAnalysis,
        recommendations: savedRecommendations,
        summary: {
          overallHealthScore: analysisResult.overallHealthScore,
          riskFactors: analysisResult.riskFactors,
          trends: analysisResult.trends,
          recommendationsCount: savedRecommendations.length
        }
      });
    } catch (error) {
      console.error("Error generating health analysis:", error);
      res.status(500).json({ 
        message: "Failed to generate health analysis",
        error: error.message 
      });
    }
  });

  const httpServer = createServer(app);
  return httpServer;
}

// Helper function to generate mock report content
function generateReportContent(report: any): string {
  const timestamp = new Date().toISOString();
  
  if (report.format === 'csv') {
    return generateCSVContent(report, timestamp);
  } else if (report.format === 'excel') {
    return generateExcelContent(report, timestamp);
  } else {
    return generatePDFContent(report, timestamp);
  }
}

function generateCSVContent(report: any, timestamp: string): string {
  const headers = ['Date', 'Type', 'Category', 'Value', 'Status'];
  const rows = [
    [timestamp.split('T')[0], report.type, 'Patients', '150', 'Active'],
    [timestamp.split('T')[0], report.type, 'Appointments', '45', 'Scheduled'],
    [timestamp.split('T')[0], report.type, 'Revenue', '$12,500', 'Collected'],
    [timestamp.split('T')[0], report.type, 'Lab Tests', '28', 'Completed'],
    [timestamp.split('T')[0], report.type, 'Prescriptions', '67', 'Dispensed']
  ];
  
  return [headers.join(','), ...rows.map(row => row.join(','))].join('\n');
}

function generateExcelContent(report: any, timestamp: string): string {
  // For Excel format, return a simple CSV-like content
  // In a real implementation, you would use a library like xlsx
  return generateCSVContent(report, timestamp);
}

function generatePDFContent(report: any, timestamp: string): string {
  // For PDF format, return plain text content
  // In a real implementation, you would use a library like pdfkit
  return `
HEALTHCARE REPORT
=================

Report Title: ${report.title}
Report Type: ${report.type}
Generated: ${timestamp}
Format: ${report.format.toUpperCase()}

SUMMARY
-------
This report contains healthcare analytics and operational data
for the selected time period and organization.

KEY METRICS
-----------
 Total Patients: 150
 Appointments Scheduled: 45
 Revenue Generated: $12,500
 Lab Tests Completed: 28
 Prescriptions Dispensed: 67

COMPLIANCE STATUS
-----------------
 HIPAA Compliance: Active
 Data Security: Verified
 Audit Trail: Complete

Generated by NAVIMED Healthcare Platform
Report ID: ${report.id}
`;
}

  // ==================== MEDICATION COPAY ROUTES ====================

  // Get medication copays for a patient
  app.get("/api/medication-copays/patient/:patientId", authenticateToken, requireTenant, async (req, res) => {
    try {
      const { patientId } = req.params;
      const copays = await storage.getMedicationCopaysByPatient(patientId, req.user.tenantId);
      res.json(copays);
    } catch (error) {
      console.error("Failed to fetch patient medication copays:", error);
      res.status(500).json({ message: "Failed to fetch medication copays" });
    }
  });

  // Get medication copays by prescription
  app.get("/api/medication-copays/prescription/:prescriptionId", authenticateToken, requireTenant, async (req, res) => {
    try {
      const { prescriptionId } = req.params;
      const copays = await storage.getMedicationCopaysByPrescription(prescriptionId, req.user.tenantId);
      res.json(copays);
    } catch (error) {
      console.error("Failed to fetch prescription medication copays:", error);
      res.status(500).json({ message: "Failed to fetch medication copays" });
    }
  });

  // Get medication copays by patient insurance
  app.get("/api/medication-copays/insurance/:patientInsuranceId", authenticateToken, requireTenant, async (req, res) => {
    try {
      const { patientInsuranceId } = req.params;
      const copays = await storage.getMedicationCopaysByPatientInsurance(patientInsuranceId, req.user.tenantId);
      res.json(copays);
    } catch (error) {
      console.error("Failed to fetch insurance medication copays:", error);
      res.status(500).json({ message: "Failed to fetch medication copays" });
    }
  });

  // Get all medication copays for tenant (pharmacist view)
  app.get("/api/medication-copays", authenticateToken, requireTenant, async (req, res) => {
    try {
      const copays = await storage.getMedicationCopaysByTenant(req.user.tenantId);
      res.json(copays);
    } catch (error) {
      console.error("Failed to fetch medication copays:", error);
      res.status(500).json({ message: "Failed to fetch medication copays" });
    }
  });

  // Get medication copays defined by current pharmacist
  app.get("/api/medication-copays/pharmacist", authenticateToken, requireTenant, requireRole(["pharmacist", "tenant_admin", "director", "super_admin"]), async (req, res) => {
    try {
      const copays = await storage.getMedicationCopaysByPharmacist(req.user.id, req.user.tenantId);
      res.json(copays);
    } catch (error) {
      console.error("Failed to fetch pharmacist medication copays:", error);
      res.status(500).json({ message: "Failed to fetch medication copays" });
    }
  });

  // Get specific medication copay
  app.get("/api/medication-copays/:id", authenticateToken, requireTenant, async (req, res) => {
    try {
      const { id } = req.params;
      const copay = await storage.getMedicationCopay(id, req.user.tenantId);
      
      if (!copay) {
        return res.status(404).json({ message: "Medication copay not found" });
      }
      
      res.json(copay);
    } catch (error) {
      console.error("Failed to fetch medication copay:", error);
      res.status(500).json({ message: "Failed to fetch medication copay" });
    }
  });

  // Create new medication copay (pharmacists only)
  app.post("/api/medication-copays", authenticateToken, requireTenant, requireRole(["pharmacist", "tenant_admin", "director", "super_admin"]), async (req, res) => {
    try {
      console.log("=== MEDICATION COPAY CREATION ===");
      console.log("Request body:", req.body);
      console.log("User:", { id: req.user.id, tenantId: req.user.tenantId });
      
      const validatedData = insertMedicationCopaySchema.parse({
        ...req.body,
        tenantId: req.user.tenantId,
        definedByPharmacist: req.user.id,
      });
      
      console.log("Validated data:", validatedData);

      const copay = await storage.createMedicationCopay(validatedData);
      console.log("Created copay:", copay);

      if (!copay) {
        console.error("Copay creation returned null/undefined");
        return res.status(500).json({ message: "Failed to create medication copay - no data returned" });
      }

      // Create audit log
      await storage.createAuditLog({
        tenantId: req.user.tenantId,
        userId: req.user.id,
        entityType: "medication_copay",
        entityId: copay.id,
        action: "CREATE",
        previousData: null,
        newData: copay,
        ipAddress: req.ip || null,
        userAgent: req.get('User-Agent') || null
      });

      console.log("Sending response:", copay);
      res.status(201).json(copay);
    } catch (error) {
      console.error("Failed to create medication copay:", error);
      res.status(500).json({ message: "Failed to create medication copay", error: error.message });
    }
  });

  // Update medication copay (pharmacists only)
  app.patch("/api/medication-copays/:id", authenticateToken, requireTenant, requireRole(["pharmacist", "tenant_admin", "director", "super_admin"]), async (req, res) => {
    try {
      const { id } = req.params;
      const updates = req.body;

      const copay = await storage.updateMedicationCopay(id, updates, req.user.tenantId);
      
      if (!copay) {
        return res.status(404).json({ message: "Medication copay not found" });
      }

      // Create audit log
      await storage.createAuditLog({
        tenantId: req.user.tenantId,
        userId: req.user.id,
        entityType: "medication_copay",
        entityId: copay.id,
        action: "UPDATE",
        previousData: null,
        newData: copay,
        ipAddress: req.ip || null,
        userAgent: req.get('User-Agent') || null
      });

      res.json(copay);
    } catch (error) {
      console.error("Failed to update medication copay:", error);
      res.status(500).json({ message: "Failed to update medication copay" });
    }
  });

  // Get active medication copays for a patient
  app.get("/api/medication-copays/patient/:patientId/active", authenticateToken, requireTenant, async (req, res) => {
    try {
      const { patientId } = req.params;
      const copays = await storage.getActiveMedicationCopaysByPatient(patientId, req.user.tenantId);
      res.json(copays);
    } catch (error) {
      console.error("Failed to fetch active medication copays:", error);
      res.status(500).json({ message: "Failed to fetch active medication copays" });
    }
  });

  // Patient insurance routes for copay form
  app.get("/api/patient-insurance/:patientId", authenticateToken, requireTenant, async (req, res) => {
    try {
      const { patientId } = req.params;
      const patientInsurance = await storage.getPatientInsurance(patientId, req.user.tenantId);
      res.json(patientInsurance);
    } catch (error) {
      console.error("Failed to fetch patient insurance:", error);
      res.status(500).json({ message: "Failed to fetch patient insurance" });
    }
  });

  // Pharmacy registration endpoint (public)
  app.post("/api/pharmacy-registration", async (req, res) => {
    try {
      console.log("Pharmacy registration request:", JSON.stringify(req.body, null, 2));
      
      const { tenant: pharmacyData, admin } = req.body;
      
      if (!pharmacyData || !admin) {
        return res.status(400).json({ 
          message: "Pharmacy and admin information are required" 
        });
      }

      // Create the pharmacy tenant
      const tenantData = {
        name: pharmacyData.name,
        type: "pharmacy" as const,
        subdomain: pharmacyData.subdomain,
        settings: pharmacyData.settings || {}
      };

      console.log("Creating pharmacy tenant:", tenantData);
      const tenant = await storage.createTenant(tenantData);
      
      // Generate a temporary password for the admin
      const tempPassword = Math.random().toString(36).slice(-8);
      const hashedPassword = await bcrypt.hash(tempPassword, 10);
      
      // Create the admin user
      const adminData = {
        tenantId: tenant.id,
        username: admin.email,
        email: admin.email,
        password: hashedPassword,
        firstName: admin.firstName,
        lastName: admin.lastName,
        role: "tenant_admin" as const,
        isActive: true
      };

      console.log("Creating admin user:", { ...adminData, password: "[HIDDEN]" });
      const adminUser = await storage.createUser(adminData);

      // In a real application, you would send an email with the temporary password
      console.log(`Pharmacy registered successfully. Admin credentials: ${admin.email} / ${tempPassword}`);

      res.status(201).json({
        message: "Pharmacy registered successfully",
        tenant: {
          id: tenant.id,
          name: tenant.name,
          subdomain: tenant.subdomain
        },
        admin: {
          id: adminUser.id,
          email: adminUser.email,
          tempPassword: tempPassword // In production, this would be sent via email
        }
      });

    } catch (error) {
      console.error("Pharmacy registration error:", error);
      res.status(500).json({ 
        message: "Registration failed", 
        error: error instanceof Error ? error.message : "Unknown error"
      });
    }
  });

  // Pricing Plans routes
  app.get('/api/pricing-plans', async (req, res) => {
    try {
      const plans = await storage.getPricingPlans();
      res.json(plans);
    } catch (error) {
      console.error('Error fetching pricing plans:', error);
      res.status(500).json({ error: 'Failed to fetch pricing plans' });
    }
  });

  // White Label Settings routes  
  app.patch('/api/tenants/:tenantId/white-label', authenticateToken, async (req, res) => {
    try {
      const { tenantId } = req.params;
      const whitelabelSettings = req.body;
      
      // Check if user has access to this tenant
      if (req.user.tenantId !== tenantId && req.user.role !== 'super_admin') {
        return res.status(403).json({ error: 'Access denied' });
      }
      
      // Get tenant info to check if it's ARGILETTE platform owner
      const tenant = await storage.getTenant(tenantId);
      if (!tenant) {
        return res.status(404).json({ error: 'Tenant not found' });
      }
      
      // ARGILETTE platform owner has unlimited white label access - no subscription check
      const isPlatformOwner = tenant.name === 'ARGILETTE' || tenant.type === 'platform';
      
      if (!isPlatformOwner) {
        // Check subscription for non-platform owners
        const subscription = await storage.getCurrentSubscription(tenantId);
        if (!subscription || (!subscription.whitelabelEnabled && subscription.plan !== 'white_label')) {
          return res.status(403).json({ 
            error: 'White label features require Enterprise or White Label subscription' 
          });
        }
      } else {
        console.log('[WHITE LABEL] ARGILETTE platform owner - unlimited white label access granted');
      }
      
      const updatedTenant = await storage.updateTenantWhiteLabel(tenantId, whitelabelSettings);
      res.json(updatedTenant);
    } catch (error) {
      console.error('Error updating white label settings:', error);
      res.status(500).json({ error: 'Failed to update white label settings' });
    }
  });

  // Offline Sync routes
  app.post('/api/offline-sync', authenticateToken, async (req, res) => {
    try {
      const syncData = req.body;
      const result = await storage.syncOfflineData(syncData);
      res.json(result);
    } catch (error) {
      console.error('Error syncing offline data:', error);
      res.status(500).json({ error: 'Failed to sync offline data' });
    }
  });

  // Translation routes
  app.get('/api/translations/:tenantId/:language', async (req, res) => {
    try {
      const { tenantId, language } = req.params;
      const translations = await storage.getTranslations(tenantId, language);
      res.json(translations);
    } catch (error) {
      console.error('Error fetching translations:', error);
      res.status(500).json({ error: 'Failed to fetch translations' });
    }
  });

  app.post('/api/translations', authenticateToken, async (req, res) => {
    try {
      const translation = req.body;
      const result = await storage.createTranslation(translation);
      res.json(result);
    } catch (error) {
      console.error('Error creating translation:', error);
      res.status(500).json({ error: 'Failed to create translation' });
    }
  });

  // ==================== TRIAL SUSPENSION ROUTES ====================
  
  // Get trial status for current tenant
  app.get("/api/trial/status", authenticateToken, requireTenant, async (req, res) => {
    try {
      const trialStatus = await trialSuspensionService.getTrialStatus(req.user.tenantId);
      
      if (!trialStatus) {
        return res.status(404).json({ message: "Tenant not found" });
      }
      
      res.json(trialStatus);
    } catch (error) {
      console.error("Failed to fetch trial status:", error);
      res.status(500).json({ message: "Failed to fetch trial status" });
    }
  });

  // Extend trial (super admin only)
  app.post("/api/trial/:tenantId/extend", authenticateToken, requireRole(["super_admin"]), async (req, res) => {
    try {
      const { tenantId } = req.params;
      const { days = 14 } = req.body;
      
      await trialSuspensionService.extendTrial(tenantId, days);
      
      res.json({ 
        message: `Trial extended by ${days} days`,
        tenantId 
      });
    } catch (error) {
      console.error("Failed to extend trial:", error);
      res.status(500).json({ message: "Failed to extend trial" });
    }
  });

  // Reactivate suspended tenant (super admin only)
  app.post("/api/trial/:tenantId/reactivate", authenticateToken, requireRole(["super_admin"]), async (req, res) => {
    try {
      const { tenantId } = req.params;
      const { subscriptionPlan = 'professional' } = req.body;
      
      await trialSuspensionService.reactivateTenant(tenantId, subscriptionPlan);
      
      res.json({ 
        message: "Tenant reactivated successfully",
        tenantId,
        subscriptionPlan
      });
    } catch (error) {
      console.error("Failed to reactivate tenant:", error);
      res.status(500).json({ message: "Failed to reactivate tenant" });
    }
  });

  // Manually trigger suspension check (super admin only)
  app.post("/api/trial/check-suspensions", authenticateToken, requireRole(["super_admin"]), async (req, res) => {
    try {
      await trialSuspensionService.checkAndSuspendExpiredTrials();
      
      res.json({ 
        message: "Suspension check completed successfully" 
      });
    } catch (error) {
      console.error("Failed to run suspension check:", error);
      res.status(500).json({ message: "Failed to run suspension check" });
    }
  });

  // Patient Check-ins for receptionist workflow
  app.get("/api/patient-check-ins", authenticateToken, requireTenant, async (req, res) => {
    try {
      const { date } = req.query;
      const checkInDate = date ? new Date(date as string) : undefined;
      const checkIns = await storage.getPatientCheckInsByTenant(req.tenant!.id, checkInDate);
      res.json(checkIns);
    } catch (error) {
      console.error("Failed to fetch patient check-ins:", error);
      res.status(500).json({ message: "Failed to fetch patient check-ins" });
    }
  });

  app.get("/api/patient-check-ins/today", authenticateToken, requireTenant, async (req, res) => {
    try {
      const checkIns = await storage.getTodaysCheckIns(req.tenant!.id);
      res.json(checkIns);
    } catch (error) {
      console.error("Failed to fetch today's check-ins:", error);
      res.status(500).json({ message: "Failed to fetch today's check-ins" });
    }
  });

  app.get("/api/patient-check-ins/waiting", authenticateToken, requireTenant, async (req, res) => {
    try {
      const waitingPatients = await storage.getWaitingPatients(req.tenant!.id);
      res.json(waitingPatients);
    } catch (error) {
      console.error("Failed to fetch waiting patients:", error);
      res.status(500).json({ message: "Failed to fetch waiting patients" });
    }
  });

  console.log("DEBUG: Reached line after waiting patients route registration");
  console.log("DEBUG: About to register POST /api/patient-check-ins route");
  app.post("/api/patient-check-ins", authenticateToken, requireTenant, requireRole(["receptionist", "nurse", "tenant_admin", "director", "super_admin"]), async (req, res) => {
    try {
      console.log("[CHECK-IN DEBUG] Request body:", req.body);
      console.log("[CHECK-IN DEBUG] Tenant ID:", req.tenant!.id);
      console.log("[CHECK-IN DEBUG] User ID:", req.user!.id);

      const validatedData = insertPatientCheckInSchema.parse({
        ...req.body,
        tenantId: req.tenant!.id,
        checkedInBy: req.user!.id
      });

      console.log("[CHECK-IN DEBUG] Validated data:", validatedData);

      const checkIn = await storage.createPatientCheckIn(validatedData);

      console.log("[CHECK-IN DEBUG] Created check-in:", checkIn);

      // Create audit log
      await storage.createAuditLog({
        tenantId: req.tenant!.id,
        userId: req.user!.id,
        entityType: "patient_check_in",
        entityId: checkIn.id,
        action: "CREATE",
        previousData: null,
        newData: checkIn,
        ipAddress: req.ip || null,
        userAgent: req.get('User-Agent') || null
      });

      res.status(201).json(checkIn);
    } catch (error) {
      console.error("[CHECK-IN DEBUG] Failed to create patient check-in:", error);
      if (error instanceof z.ZodError) {
        console.error("[CHECK-IN DEBUG] Validation errors:", error.errors);
        return res.status(400).json({ message: "Validation error", errors: error.errors });
      }
      res.status(500).json({ message: "Failed to create patient check-in" });
    }
  });

  app.patch("/api/patient-check-ins/:id", authenticateToken, requireTenant, requireRole(["receptionist", "nurse", "tenant_admin", "director", "super_admin"]), async (req, res) => {
    try {
      const { id } = req.params;
      const updates = req.body;

      const originalCheckIn = await storage.getPatientCheckIn(id, req.tenant!.id);
      if (!originalCheckIn) {
        return res.status(404).json({ message: "Patient check-in not found" });
      }

      const updatedCheckIn = await storage.updatePatientCheckIn(id, updates, req.tenant!.id);
      if (!updatedCheckIn) {
        return res.status(404).json({ message: "Patient check-in not found" });
      }

      // Create audit log
      await storage.createAuditLog({
        tenantId: req.tenant!.id,
        userId: req.user!.id,
        entityType: "patient_check_in",
        entityId: id,
        action: "UPDATE",
        previousData: originalCheckIn,
        newData: updatedCheckIn,
        ipAddress: req.ip || null,
        userAgent: req.get('User-Agent') || null
      });

      res.json(updatedCheckIn);
    } catch (error) {
      console.error("Failed to update patient check-in:", error);
      res.status(500).json({ message: "Failed to update patient check-in" });
    }
  });

  return server;
}
